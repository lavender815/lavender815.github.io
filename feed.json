{
    "version": "https://jsonfeed.org/version/1",
    "title": "Lavender",
    "subtitle": "",
    "icon": "http://example.com/images/favicon.ico",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/08/18/hello-world/",
            "url": "http://example.com/2022/08/18/hello-world/",
            "title": "Hello World",
            "date_published": "2022-08-18T02:09:14.000Z",
            "content_html": "<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"quick-start\"><a class=\"anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo new <span class=\"token string\">\"My New Post\"</span></pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"run-server\"><a class=\"anchor\" href=\"#run-server\">#</a> Run server</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo server</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"generate-static-files\"><a class=\"anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo generate</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo deploy</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n",
            "tags": [
                "Hello",
                "Hello"
            ]
        },
        {
            "id": "http://example.com/2022/07/01/Python%20Handbook/",
            "url": "http://example.com/2022/07/01/Python%20Handbook/",
            "title": "Python",
            "date_published": "2022-07-01T03:00:00.000Z",
            "content_html": "<h1 id=\"python\"><a class=\"anchor\" href=\"#python\">#</a> Python</h1>\n<ul>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-Python-%E7%94%9F%E6%88%90%E5%99%A8\">什么是 Python 生成器？</a></li>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-Python-%E8%BF%AD%E4%BB%A3%E5%99%A8\">什么是 Python 迭代器？</a></li>\n<li><a href=\"#list-%E5%92%8C-tuple-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\">list 和 tuple 有什么区别？</a></li>\n<li><a href=\"#Python-%E4%B8%AD%E7%9A%84-list-%E5%92%8C-dict-%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84\">Python 中的 list 和 dict 是怎么实现的？</a></li>\n<li><a href=\"#Python-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E8%BE%BE%E5%88%B0%E5%A4%9A%E6%A0%B8CPU%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E5%90%97\">Python 中使用多线程可以达到多核 CPU 一起使用吗？</a></li>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A3%85%E9%A5%B0%E5%99%A8\">什么是装饰器？</a></li>\n<li><a href=\"#Python-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86\">Python 如何进行内存管理？</a></li>\n<li><a href=\"#Python-%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6\">Python 中的垃圾回收机制？</a></li>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F\">什么是 lambda 表达式？</a></li>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D\">什么是深拷贝和浅拷贝？</a></li>\n<li><a href=\"#%E5%8F%8C%E7%AD%89%E4%BA%8E%E5%92%8C-is-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\">双等于和 is 有什么区别？</a></li>\n<li><a href=\"#%E5%85%B6%E5%AE%83-Python-%E7%9F%A5%E8%AF%86%E7%82%B9\">其它 Python 知识点</a></li>\n<li><a href=\"#%E5%8F%82%E8%80%83\">参考</a></li>\n</ul>\n<hr />\n<h2 id=\"什么是-python-生成器\"><a class=\"anchor\" href=\"#什么是-python-生成器\">#</a> 什么是 Python 生成器？</h2>\n<p>generator，有两种产生生成器对象的方式：一种是列表生成式加括号：</p>\n<p><code>g1 = (x for x in range(10))</code></p>\n<p>一种是在函数定义中包含 <code>yield</code>  关键字：</p>\n<figure class=\"highlight py\"><figcaption data-lang=\"Python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">def</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">max</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    n<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">while</span> n <span class=\"token operator\">&lt;</span> <span class=\"token builtin\">max</span><span class=\"token punctuation\">:</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        <span class=\"token keyword\">yield</span> b</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        a<span class=\"token punctuation\">,</span> b <span class=\"token operator\">=</span> b<span class=\"token punctuation\">,</span> a <span class=\"token operator\">+</span> b</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>        n <span class=\"token operator\">=</span> n <span class=\"token operator\">+</span> <span class=\"token number\">1</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    <span class=\"token keyword\">return</span> <span class=\"token string\">'done'</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>g2 <span class=\"token operator\">=</span> fib<span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>对于 generator 对象 g1 和 g2，可以通过 <code>next(g1)</code>  不断获得下一个元素的值，如果没有更多的元素，就会报错 <code>StopIteration</code></p>\n<p>也可以通过 for 循环获得元素的值。</p>\n<p>生成器的好处是不用占用很多内存，只需要在用的时候计算元素的值就行了。</p>\n<h2 id=\"什么是-python-迭代器\"><a class=\"anchor\" href=\"#什么是-python-迭代器\">#</a> 什么是 Python 迭代器？</h2>\n<p>Python 中可以用于 for 循环的，叫做可迭代 <code>Iterable</code> ，包括 list/set/tuple/str/dict 等数据结构以及生成器；可以用以下语句判断一个对象是否是可迭代的：</p>\n<figure class=\"highlight py\"><figcaption data-lang=\"Python\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">from</span> collections <span class=\"token keyword\">import</span> Iterable</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token builtin\">isinstance</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> Iterable<span class=\"token punctuation\">)</span></pre></td></tr></table></figure><p>迭代器 <code>Iterator</code> ，是指可以被 <code>next()</code>  函数调用并不断返回下一个值，直到 <code>StopIteration</code> ；生成器都是 Iterator，而列表等数据结构不是；可以通过以下语句将 list 变为 Iterator：</p>\n<p><code>iter([1,2,3,4,5])</code></p>\n<p>生成器都是 Iterator，但迭代器不一定是生成器。</p>\n<h2 id=\"list-和-tuple-有什么区别\"><a class=\"anchor\" href=\"#list-和-tuple-有什么区别\">#</a> list 和 tuple 有什么区别？</h2>\n<ul>\n<li>list 长度可变，tuple 不可变；</li>\n<li>list 中元素的值可以改变，tuple 不能改变；</li>\n<li>list 支持 <code>append</code> ;  <code>insert</code> ;  <code>remove</code> ;  <code>pop</code>  等方法，tuple 都不支持</li>\n</ul>\n<h2 id=\"python-中的-list-和-dict-是怎么实现的\"><a class=\"anchor\" href=\"#python-中的-list-和-dict-是怎么实现的\">#</a> Python 中的 list 和 dict 是怎么实现的？</h2>\n<h2 id=\"python-中使用多线程可以达到多核cpu一起使用吗\"><a class=\"anchor\" href=\"#python-中使用多线程可以达到多核cpu一起使用吗\">#</a> Python 中使用多线程可以达到多核 CPU 一起使用吗？</h2>\n<p>Python 中有一个被称为 Global Interpreter Lock（GIL）的东西，它会确保任何时候你的多个线程中，只有一个被执行。线程的执行速度非常之快，会让你误以为线程是并行执行的，但是实际上都是轮流执行。经过 GIL 这一道关卡处理，会增加执行的开销。</p>\n<p>可以通过多进程实现多核任务。</p>\n<h2 id=\"gilglobal-interpreter-lock\"><a class=\"anchor\" href=\"#gilglobal-interpreter-lock\">#</a> GIL(Global Interpreter Lock)</h2>\n<p>全局解释器锁</p>\n<p>全局解释器锁 (Global Interpreter Lock) 是计算机程序设计语言解释器用于同步线程的一种机制，它使得任何时刻仅有一个线程在执行。即便在多核处理器上，使用 GIL 的解释器也只允许同一时间执行一个线程，常见的使用 GIL 的解释器有 CPython 与 Ruby MRI。可以看到 GIL 并不是 Python 独有的特性，是解释型语言处理多线程问题的一种机制而非语言特性。</p>\n<h3 id=\"gil的设计初衷\"><a class=\"anchor\" href=\"#gil的设计初衷\">#</a> GIL 的设计初衷？</h3>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;<br />\n 单核时代高效利用 CPU, 针对解释器级别的数据安全 (不是 thread-safe 线程安全)。<br />\n首先需要明确的是 GIL 并不是 Python 的特性，它是在实现 Python 解析器 (CPython) 时所引入的一个概念。当 Python 虚拟机的线程想要调用 C 的原生线程需要知道线程的上下文，因为没有办法控制 C 的原生线程的执行，所以只能把上下文关系传给原生线程，同理获取结果也是线<br />\n程在 python 虚拟机这边等待。那么要执行一次计算操作，就必须让执行程序的线程组串行执行。<br />\n&lt;/details&gt;</p>\n<h3 id=\"为什么要加在解释器而不是在其他层\"><a class=\"anchor\" href=\"#为什么要加在解释器而不是在其他层\">#</a> 为什么要加在解释器，而不是在其他层？</h3>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;<br />\nGIL 锁加在解释器一层，也就是说 Python 调用的 Cython 解释器上加了 GIL 锁，因为你 python 调用的所有线程都是原生线程。原生线程是通过 C 语言提供原生接口，相当于 C 语言的一个函数。你一调它，你就控制不了了它了，就必须等它给你返回结果。只要已通过 python 虚拟机<br />\n，再往下就不受 python 控制了，就是 C 语言自己控制了。加在 Python 虚拟机以下加不上去，只能加在 Python 解释器这一层。<br />\n&lt;/details&gt;</p>\n<h3 id=\"gil的实现是线程不安全为什么\"><a class=\"anchor\" href=\"#gil的实现是线程不安全为什么\">#</a> GIL 的实现是线程不安全？为什么？</h3>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;<br />\n 是不安全的，具体情况要分类讨论。</p>\n<p>单核情况下:</p>\n<p><img data-src=\"https://images2017.cnblogs.com/blog/1088183/201709/1088183-20170926140930839-80064182.png\" alt=\"单核情况下——线程不安全\" /></p>\n<blockquote>\n<p>解释:</p>\n<ol>\n<li>到第 5 步的时候，可能这个时候 python 正好切换了一次 GIL (据说 python2.7 中，每 100 条指令会切换一次 GIL), 执行的时间到了，被要求释放 GIL, 这个时候 thead 1 的 count=0 并没有得到执行，而是挂起状态，count=0 这个上下文关系被存到寄存器中.</li>\n<li>然后到第 6 步，这个时候 thead 2 开始执行，然后就变成了 count = 1, 返回给 count，这个时候 count=1.</li>\n<li>然后再回到 thead 1，这个时候由于上下文关系，thead 1 拿到的寄存器中的 count = 0，经过计算，得到 count = 1，经过第 13 步的操作就覆盖了原来的 count = 1 的值，所以这个时候 count 依然是 count = 1，所以这个数据并没有保护起来。</li>\n</ol>\n</blockquote>\n<p>python2.x 和 3.x 都是在执行 IO 操作的时候，强制释放 GIL，使其他线程有机会执行程序。</p>\n<p>Python2.x Python 使用计数器 ticks 计算字节码，当执行 100 个字节码的时候强制释放 GIL，其他线程获取 GIL 继续执行。ticks 可以看作是 Python 自己的计数器，专门作用于 GIL，释放后归零，技术可以调整。</p>\n<p>Python3.x Python 使用计时器，执行时间达到阈值后，当前线程释放 GIL。总体来说比 Python3.x 对 CPU 密集型任务更好，但是依然没有解决问题。</p>\n<p>多核情况下:</p>\n<p>多个 CPU 情况下，单个 CPU 释放 GIL 锁，其他 CPU 上的线程也会竞争，但是 CPU-A 可能又马上拿到了 GIL，这样其他 CPU 上的线程只能继续等待，直到重新回到待调度状态。造成多线程在多核 CPU 情况下，效率反而会下降，出现了大量的资源浪费。<br />\n&lt;/details&gt;</p>\n<h2 id=\"什么是装饰器\"><a class=\"anchor\" href=\"#什么是装饰器\">#</a> 什么是装饰器？</h2>\n<h2 id=\"python-中的垃圾回收机制\"><a class=\"anchor\" href=\"#python-中的垃圾回收机制\">#</a> Python 中的垃圾回收机制？</h2>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8xZTM3NWZiNDA1MDY=\">Python 垃圾回收机制 -- 完美讲解！</span></p>\n<h2 id=\"什么是-lambda-表达式\"><a class=\"anchor\" href=\"#什么是-lambda-表达式\">#</a> 什么是 lambda 表达式？</h2>\n<p>简单来说，lambda 表达式通常是当你需要使用一个函数，但是又不想费脑袋去命名一个函数的时候使用，也就是通常所说的匿名函数。</p>\n<p>lambda 表达式一般的形式是：关键词 lambda 后面紧接一个或多个参数，紧接一个冒号 “：”，紧接一个表达式</p>\n<h2 id=\"什么是深拷贝和浅拷贝\"><a class=\"anchor\" href=\"#什么是深拷贝和浅拷贝\">#</a> 什么是深拷贝和浅拷贝？</h2>\n<p>赋值（=），就是创建了对象的一个新的引用，修改其中任意一个变量都会影响到另一个。</p>\n<p>浅拷贝 copy.copy：创建一个新的对象，但它包含的是对原始对象中包含项的引用（如果用引用的方式修改其中一个对象，另外一个也会修改改变）</p>\n<p copy模块的deep.deepcopy()函数=\"\">深拷贝：创建一个新的对象，并且递归的复制它所包含的对象（修改其中一个，另外一个不会改变）</p>\n<h2 id=\"双等于和-is-有什么区别\"><a class=\"anchor\" href=\"#双等于和-is-有什么区别\">#</a> 双等于和 is 有什么区别？</h2>\n<p><code>==</code>  比较的是两个变量的 value，只要值相等就会返回 True</p>\n<p><code>is</code>  比较的是两个变量的 id，即 <code>id(a) == id(b)</code> ，只有两个变量指向同一个对象的时候，才会返回 True</p>\n<p>但是需要注意的是，比如以下代码：</p>\n<pre><code>a = 2\nb = 2\nprint(a is b)\n</code></pre>\n<p>按照上面的解释，应该会输出 False，但是事实上会输出 True，这是因为 Python 中对小数据有缓存机制，-5~256 之间的数据都会被缓存。</p>\n<hr />\n<h2 id=\"其它-python-知识点\"><a class=\"anchor\" href=\"#其它-python-知识点\">#</a> 其它 Python 知识点</h2>\n<h3 id=\"类型转换\"><a class=\"anchor\" href=\"#类型转换\">#</a> 类型转换</h3>\n<ul>\n<li>list(x)</li>\n<li>str(x)</li>\n<li>set(x)</li>\n<li>int(x)</li>\n<li>tuple(x)</li>\n</ul>\n<h3 id=\"tryexcept\"><a class=\"anchor\" href=\"#tryexcept\">#</a> try...except</h3>\n<h3 id=\"list\"><a class=\"anchor\" href=\"#list\">#</a> list</h3>\n<ul>\n<li><code>lst[a:b]</code> ：左闭右开</li>\n<li><code>lst.append(value)</code> ：在末尾添加元素，复杂度 O (1)</li>\n<li><code>lst.pop()</code> ：弹出列表末尾元素，复杂度 O (1)</li>\n<li><code>lst.pop(index)</code> ：弹出任意位置元素，将后面的元素前移，复杂度 O (n)</li>\n<li><code>lst.insert(index, value)</code> ：插入元素，后面的元素后移，复杂度 O (n)</li>\n<li><code>lst.remove(value)</code> ：移除等于 value 的第一个元素，后面的元素前移，复杂度 O (n)</li>\n<li><code>lst.count(value)</code> ：计数值为 value 的元素个数</li>\n<li><code>lst.sort(reverse = False)</code> ：排序，默认升序</li>\n</ul>\n<h3 id=\"参考\"><a class=\"anchor\" href=\"#参考\">#</a> 参考</h3>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMTAxNjk1OTY2MzYwMjQwMC8xMDE3MzE4MjA3Mzg4MTI4\">生成器 - 廖雪峰的官方网站</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veWp0eGluL3AvMTE3OTMyNDMuaHRtbA==\">Python 中的 is 和 == 的区别</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubWRlZGl0b3IudHcvcGwvcFhoag==\">为什么 Python 多线程无法利用多核</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vS2VlcC1BbWJpdGlvbi9wLzc1OTYwOTguaHRtbA==\">GIL 锁、线程锁 (互斥锁)、递归锁 (RLock)</span></li>\n</ul>\n",
            "tags": [
                "学习",
                "Python"
            ]
        },
        {
            "id": "http://example.com/2022/06/30/Operating%20Systems/",
            "url": "http://example.com/2022/06/30/Operating%20Systems/",
            "title": "操作系统",
            "date_published": "2022-06-30T03:00:00.000Z",
            "content_html": "<h1 id=\"操作系统\"><a class=\"anchor\" href=\"#操作系统\">#</a> 操作系统</h1>\n<ul>\n<li>进程和线程\n<ul>\n<li><a href=\"#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\">进程和线程有什么区别？</a></li>\n<li><a href=\"#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F\">进程间通信有哪些方式？</a></li>\n<li><a href=\"#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98\">进程同步问题</a></li>\n<li><a href=\"#%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81\">进程有哪几种状态？</a></li>\n<li><a href=\"#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B\">进程调度策略有哪些？</a></li>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B\">什么是僵尸进程？</a></li>\n<li><a href=\"#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F\">线程同步有哪些方式？</a></li>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E7%A8%8B\">什么是协程？</a></li>\n<li><a href=\"#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%9A%E9%99%B7%E9%98%B1%E3%80%81%E4%B8%AD%E6%96%AD%E3%80%81%E5%BC%82%E5%B8%B8%E5%92%8C%E4%BF%A1%E5%8F%B7\">进程的异常控制流：陷阱、中断、异常和信号</a></li>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AFIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0\">什么是 IO 多路复用？怎么实现？</a></li>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81\">什么是用户态和内核态？</a></li>\n</ul>\n</li>\n<li>死锁\n<ul>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81\">什么是死锁？</a></li>\n<li><a href=\"#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6\">死锁产生的必要条件？</a></li>\n<li><a href=\"#%E6%AD%BB%E9%94%81%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95\">死锁有哪些处理方法？</a></li>\n</ul>\n</li>\n<li>内存管理\n<ul>\n<li><a href=\"#%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\">分页和分段有什么区别？</a></li>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98\">什么是虚拟内存？</a></li>\n<li><a href=\"#%E6%9C%89%E5%93%AA%E4%BA%9B%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95\">有哪些页面置换算法？</a></li>\n<li><a href=\"#%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98\">缓冲区溢出问题</a></li>\n</ul>\n</li>\n<li><a href=\"#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6\">磁盘调度</a></li>\n<li><a href=\"#%E5%8F%82%E8%80%83\">参考</a></li>\n</ul>\n<hr />\n<h3 id=\"进程和线程有什么区别\"><a class=\"anchor\" href=\"#进程和线程有什么区别\">#</a> 进程和线程有什么区别？</h3>\n<ul>\n<li>进程（Process）是系统进行资源分配和调度的基本单位，线程（Thread）是 CPU 调度和分派的基本单位；</li>\n<li>线程依赖于进程而存在，一个进程至少有一个线程；</li>\n<li>进程有自己的独立地址空间，线程共享所属进程的地址空间；</li>\n<li>进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源 (如程序计数器，一组寄存器和栈)，和其他线程共享本进程的相关资源如内存、I/O、cpu 等；</li>\n<li>在进程切换时，涉及到整个当前进程 CPU 环境的保存环境的设置以及新被调度运行的 CPU 环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换的开销远大于线程切换的开销；</li>\n<li>线程之间的通信更方便，同一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信 (IPC) 的方式进行；</li>\n<li>多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮</li>\n</ul>\n<p>进程操作代码实现，可以参考：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMTAxNjk1OTY2MzYwMjQwMC8xMDE3NjI4MjkwMTg0MDY0\">多进程 - 廖雪峰的官方网站</span></p>\n<h5 id=\"同一进程中的线程可以共享哪些数据\"><a class=\"anchor\" href=\"#同一进程中的线程可以共享哪些数据\">#</a> 同一进程中的线程可以共享哪些数据？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</p>\n<ul>\n<li>进程代码段</li>\n<li>进程的公有数据（全局变量、静态变量...）</li>\n<li>进程打开的文件描述符</li>\n<li>进程的当前目录</li>\n<li>信号处理器 / 信号处理函数：对收到的信号的处理方式</li>\n<li>进程 ID 与进程组 ID<br />\n&lt;/details&gt;</li>\n</ul>\n<h5 id=\"线程独占哪些资源\"><a class=\"anchor\" href=\"#线程独占哪些资源\">#</a> 线程独占哪些资源？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</p>\n<ul>\n<li>线程 ID</li>\n<li>一组寄存器的值</li>\n<li>线程自身的栈（堆是共享的）</li>\n<li>错误返回码：线程可能会产生不同的错误返回码，一个线程的错误返回码不应该被其它线程修改；</li>\n<li>信号掩码 / 信号屏蔽字 (Signal mask)：表示是否屏蔽 / 阻塞相应的信号（SIGKILL,SIGSTOP 除外）<br />\n&lt;/details&gt;</li>\n</ul>\n<h3 id=\"进程间通信有哪些方式\"><a class=\"anchor\" href=\"#进程间通信有哪些方式\">#</a> 进程间通信有哪些方式？</h3>\n<ol>\n<li>管道 (Pipe)<br />\n&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</li>\n</ol>\n<ul>\n<li>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；</li>\n<li>一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据；</li>\n<li>只能用于父子进程或者兄弟进程之间 (具有亲缘关系的进程)<br />\n&lt;/details&gt;</li>\n</ul>\n<ol start=\"2\">\n<li>命名管道</li>\n<li>消息队列</li>\n<li>信号 (Signal)</li>\n<li>共享内存</li>\n<li>信号量 (Semaphore)：初始化操作、P 操作、V 操作；P 操作：信号量 - 1，检测是否小于 0，小于则进程进入阻塞状态；V 操作：信号量 + 1，若小于等于 0，则从队列中唤醒一个等待的进程进入就绪态</li>\n<li>套接字 (Socket)</li>\n</ol>\n<p>更详细的可以参考（待整理）：</p>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pbWFnZXNsci5naXRodWIuaW8vMjAyMC8wMi8yNi9pcGMuaHRtbA==\">https://imageslr.github.io/2020/02/26/ipc.html</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9jMTAxNWY1ZmZhNzQ=\">https://www.jianshu.com/p/c1015f5ffa74</span></li>\n</ul>\n<h3 id=\"进程同步问题\"><a class=\"anchor\" href=\"#进程同步问题\">#</a> 进程同步问题</h3>\n<blockquote>\n<p>进程的同步是目的，而进程间通信是实现进程同步的手段</p>\n</blockquote>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 管程 Monitor&lt;/summary&gt;</p>\n<p>管程将共享变量以及对这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，这样只能通过管程提供的某个过程才能访问管程中的资源。进程只能互斥地使用管程，使用完之后必须释放管程并唤醒入口等待队列中的进程。</p>\n<p>当一个进程试图进入管程时，在<strong>入口等待队列</strong>等待。若 P 进程唤醒了 Q 进程，则 Q 进程先执行，P 在<strong>紧急等待队列</strong>中等待。（<strong>HOARE 管程</strong>）</p>\n<p>wait 操作：执行 wait 操作的进程进入条件变量链末尾，唤醒紧急等待队列或者入口队列中的进程；signal 操作：唤醒条件变量链中的进程，自己进入紧急等待队列，若条件变量链为空，则继续执行。（<strong>HOARE 管程</strong>）</p>\n<p><strong>MESA 管程</strong>：将 HOARE 中的 signal 换成了 notify（或者 broadcast 通知所有满足条件的），进行通知而不是立马交换管程的使用权，在合适的时候，条件队列首位的进程可以进入，进入之前必须用 while 检查条件是否合适。优点：没有额外的进程切换<br />\n &lt;/details&gt;</p>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 生产者 - 消费者问题 &lt;/summary&gt;</p>\n<blockquote>\n<p>问题描述：使用一个缓冲区来存放数据，只有缓冲区没有满，生产者才可以写入数据；只有缓冲区不为空，消费者才可以读出数据</p>\n</blockquote>\n<p>代码实现：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">// 伪代码描述 </span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token comment\">// 定义信号量 full 记录缓冲区物品数量 empty 代表缓冲区空位数量 mutex 为互斥量</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>semaphore full <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> empty <span class=\"token operator\">=</span> n<span class=\"token punctuation\">,</span> mutex <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token comment\">// 生产者进程</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">producer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t<span class=\"token keyword\">do</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>   \t  <span class=\"token function\">P</span><span class=\"token punctuation\">(</span>empty<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t  <span class=\"token function\">P</span><span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>     <span class=\"token comment\">// 生产者进行生产</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>   \t</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>   \t  <span class=\"token function\">V</span><span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>   \t  <span class=\"token function\">V</span><span class=\"token punctuation\">(</span>full<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre> \t<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">consumer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre>\t<span class=\"token keyword\">do</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>\t  <span class=\"token function\">P</span><span class=\"token punctuation\">(</span>full<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>\t  <span class=\"token function\">P</span><span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    \t<span class=\"token comment\">// 消费者进行消费</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>\t  <span class=\"token function\">V</span><span class=\"token punctuation\">(</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>\t  <span class=\"token function\">V</span><span class=\"token punctuation\">(</span>empty<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre> \t<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>&lt;/details&gt;</p>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 哲学家就餐问题 &lt;/summary&gt;</p>\n<blockquote>\n<p>问题描述：有五位哲学家围绕着餐桌坐，每一位哲学家要么思考，要么吃饭。为了吃饭，哲学家必须拿起两双筷子（分别放于左右两端）不幸的是，筷子的数量和哲学家相等，所以每只筷子必须由两位哲学家共享。</p>\n</blockquote>\n<p>代码实现：</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">N</span> <span class=\"token expression\"><span class=\"token number\">5</span>  </span><span class=\"token comment\">// number of philosopher</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">LEFT</span> <span class=\"token expression\"><span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> N <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">%</span>N </span><span class=\"token comment\">// number of i's left neighbors</span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">RIGHT</span> <span class=\"token expression\"><span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token operator\">%</span>N </span><span class=\"token comment\">// number of i's right neighbors</span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">THINKING</span> <span class=\"token expression\"><span class=\"token number\">0</span></span></span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">HUNGRY</span> <span class=\"token expression\"><span class=\"token number\">1</span></span></span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">define</span> <span class=\"token macro-name\">EATING</span> <span class=\"token expression\"><span class=\"token number\">2</span></span></span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">int</span> semaphore<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">int</span> state<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// array to keep track of everyone's state</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>semaphore mutex <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// mutual exclusion of critical region</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>semaphore s<span class=\"token punctuation\">[</span>N<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"11\"></td><td><pre></pre></td></tr><tr><td data-num=\"12\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">philosopher</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>TRUE<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t\t<span class=\"token function\">think</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t\t<span class=\"token function\">take_forks</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>\t\t<span class=\"token function\">eat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>\t\t<span class=\"token function\">put_forks</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre></pre></td></tr><tr><td data-num=\"21\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">take_forks</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>\t<span class=\"token function\">down</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// enter critical region</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>\tstate<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> HUNGRY<span class=\"token punctuation\">;</span> <span class=\"token comment\">// record that i is hungry</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>\t<span class=\"token function\">test_forks</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// try to acquire two forks</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>\t<span class=\"token function\">up</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// exit critical region</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>\t<span class=\"token function\">down</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// block if forks are not acquired</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"28\"></td><td><pre></pre></td></tr><tr><td data-num=\"29\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">put_forks</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"30\"></td><td><pre>\t<span class=\"token function\">down</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// enter critical region</span></pre></td></tr><tr><td data-num=\"31\"></td><td><pre>\tstate<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> THINKING<span class=\"token punctuation\">;</span> <span class=\"token comment\">// record that has finished eating</span></pre></td></tr><tr><td data-num=\"32\"></td><td><pre>\t<span class=\"token function\">test_forks</span><span class=\"token punctuation\">(</span>LEFT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// see if left neighbor can now eat</span></pre></td></tr><tr><td data-num=\"33\"></td><td><pre>\t<span class=\"token function\">test_forks</span><span class=\"token punctuation\">(</span>RIGHT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// see if right neighbor can now eat</span></pre></td></tr><tr><td data-num=\"34\"></td><td><pre>\t<span class=\"token function\">up</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>mutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// exit critical region</span></pre></td></tr><tr><td data-num=\"35\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"36\"></td><td><pre></pre></td></tr><tr><td data-num=\"37\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">test_forks</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"38\"></td><td><pre>\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> HUNGRY <span class=\"token operator\">&amp;&amp;</span> state<span class=\"token punctuation\">[</span>LEFT<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> EATING <span class=\"token operator\">&amp;&amp;</span> state<span class=\"token punctuation\">[</span>RIGHT<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> EATING<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"39\"></td><td><pre>\t\tstate<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> EATING<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"40\"></td><td><pre>\t\t<span class=\"token function\">up</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"41\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"42\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>&lt;/details&gt;</p>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 读者 - 写者问题 &lt;/summary&gt;</p>\n<p>&lt;/details&gt;</p>\n<h5 id=\"临界区的概念\"><a class=\"anchor\" href=\"#临界区的概念\">#</a> 临界区的概念？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</p>\n<p>各个进程中对临界资源（互斥资源 / 共享变量，一次只能给一个进程使用）进行操作的程序片段<br />\n &lt;/details&gt;</p>\n<h5 id=\"同步与互斥的概念\"><a class=\"anchor\" href=\"#同步与互斥的概念\">#</a> 同步与互斥的概念？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</p>\n<ul>\n<li>同步：多个进程因为合作而使得进程的执行有一定的先后顺序。比如某个进程需要另一个进程提供的消息，获得消息之前进入阻塞态；</li>\n<li>互斥：多个进程在同一时刻只有一个进程能进入临界区<br />\n &lt;/details&gt;</li>\n</ul>\n<h5 id=\"并发-并行-异步的区别\"><a class=\"anchor\" href=\"#并发-并行-异步的区别\">#</a> 并发、并行、异步的区别？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</p>\n<p>并发：在一个时间段中同时有多个程序在运行，但其实任一时刻，只有一个程序在 CPU 上运行，宏观上的并发是通过不断的切换实现的；</p>\n<p>多线程：并发运行的一段代码。是实现异步的手段</p>\n<p>并行（和串行相比）：在多 CPU 系统中，多个程序无论宏观还是微观上都是同时执行的</p>\n<p>异步（和同步相比）：同步是顺序执行，异步是在等待某个资源的时候继续做自己的事<br />\n &lt;/details&gt;</p>\n<h3 id=\"进程有哪几种状态\"><a class=\"anchor\" href=\"#进程有哪几种状态\">#</a> 进程有哪几种状态？</h3>\n<p><img data-src=\"_v_images/20191202090217863_1873.png\" alt=\"Process State\" /></p>\n<ul>\n<li>就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源</li>\n<li>运行状态：占用处理机资源运行，处于此状态的进程数小于等于 CPU 数</li>\n<li>阻塞状态： 进程等待某种条件，在条件满足之前无法执行</li>\n</ul>\n<h3 id=\"进程调度策略有哪些\"><a class=\"anchor\" href=\"#进程调度策略有哪些\">#</a> 进程调度策略有哪些？</h3>\n<ol>\n<li><strong>批处理系统</strong>：</li>\n</ol>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 先来先服务 first-come first-serverd（FCFS）&lt;/summary&gt;</p>\n<p>按照请求的顺序进行调度。非抢占式，开销小，无饥饿问题，响应时间不确定（可能很慢）；</p>\n<p>对短进程不利，对 IO 密集型进程不利。<br />\n&lt;/details&gt;</p>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 最短作业优先 shortest job first（SJF）&lt;/summary&gt;</p>\n<p>按估计运行时间最短的顺序进行调度。非抢占式，吞吐量高，开销可能较大，可能导致饥饿问题；</p>\n<p>对短进程提供好的响应时间，对长进程不利。<br />\n&lt;/details&gt;</p>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 最短剩余时间优先 shortest remaining time next（SRTN）&lt;/summary&gt;</p>\n<p>按剩余运行时间的顺序进行调度。(最短作业优先的抢占式版本)。吞吐量高，开销可能较大，提供好的响应时间；</p>\n<p>可能导致饥饿问题，对长进程不利。<br />\n&lt;/details&gt;</p>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 最高响应比优先 Highest Response Ratio Next（HRRN）&lt;/summary&gt;</p>\n<p>响应比 = 1+ 等待时间 / 处理时间。同时考虑了等待时间的长短和估计需要的执行时间长短，很好的平衡了长短进程。非抢占，吞吐量高，开销可能较大，提供好的响应时间，无饥饿问题。<br />\n&lt;/details&gt;</p>\n<ol start=\"2\">\n<li><strong>交互式系统</strong><br />\n交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</li>\n</ol>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 时间片轮转 Round Robin&lt;/summary&gt;</p>\n<p>将所有就绪进程按 FCFS 的原则排成一个队列，用完时间片的进程排到队列最后。抢占式（时间片用完时），开销小，无饥饿问题，为短进程提供好的响应时间；</p>\n<p>若时间片小，进程切换频繁，吞吐量低；若时间片太长，实时性得不到保证。<br />\n&lt;/details&gt;</p>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 优先级调度算法 &lt;/summary&gt;</p>\n<p>为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。<br />\n&lt;/details&gt;</p>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 多级反馈队列调度算法 Multilevel Feedback Queue&lt;/summary&gt;</p>\n<p>设置多个就绪队列 1、2、3...，优先级递减，时间片递增。只有等到优先级更高的队列为空时才会调度当前队列中的进程。如果进程用完了当前队列的时间片还未执行完，则会被移到下一队列。</p>\n<p>抢占式（时间片用完时），开销可能较大，对 IO 型进程有利，可能会出现饥饿问题。<br />\n&lt;/details&gt;</p>\n<h5 id=\"什么叫优先级反转如何解决\"><a class=\"anchor\" href=\"#什么叫优先级反转如何解决\">#</a> 什么叫优先级反转？如何解决？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</p>\n<p>高优先级的进程等待被一个低优先级进程占用的资源时，就会出现优先级反转，即优先级较低的进程比优先级较高的进程先执行。此处详细解释优先级反转带来的问题：如果有一个中等优先级的进程将低优先级的进程抢占，那么此时低优先级的进程无法正常进行并在后续释放被占用的资源，导致高优先级的任务一直被挂起，直到中等优先级的进程完成后，低优先级的进程才可以继续并在后续释放占用的资源，最后高优先级的进程才可以执行。导致的问题就是高优先级的进程在中等优先级的进程调度之后。</p>\n<p>解决方法：</p>\n<ul>\n<li>优先级天花板 (priority ceiling)：当任务申请某资源时，把该任务的优先级提升到可访问这个资源的所有任务中的最高优先级，这个优先级称为该资源的优先级天花板。简单易行。</li>\n<li>优先级继承 (priority inheritance)：当任务 A 申请共享资源 S 时，如果 S 正在被任务 C 使用，通过比较任务 C 与自身的优先级，如发现任务 C 的优先级小于自身的优先级，则将任务 C 的优先级提升到自身的优先级，任务 C 释放资源 S 后，再恢复任务 C 的原优先级。<br />\n&lt;/details&gt;</li>\n</ul>\n<h3 id=\"什么是僵尸进程\"><a class=\"anchor\" href=\"#什么是僵尸进程\">#</a> 什么是僵尸进程？</h3>\n<p>一个子进程结束后，它的父进程并没有等待它（调用 wait 或者 waitpid），那么这个子进程将成为一个僵尸进程。僵尸进程是一个已经死亡的进程，但是并没有真正被销毁。它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程表中保留一个位置，记载该进程的进程 ID、终止状态以及资源利用信息 (CPU 时间，内存使用量等等) 供父进程收集，除此之外，僵尸进程不再占有任何内存空间。这个僵尸进程可能会一直留在系统中直到系统重启。</p>\n<p>危害：占用进程号，而系统所能使用的进程号是有限的；占用内存。</p>\n<p>以下情况不会产生僵尸进程：</p>\n<ul>\n<li>该进程的父进程先结束了。每个进程结束的时候，系统都会扫描是否存在子进程，如果有则用 Init 进程接管，成为该进程的父进程，并且会调用 wait 等待其结束。</li>\n<li>父进程调用 wait 或者 waitpid 等待子进程结束（需要每隔一段时间查询子进程是否结束）。wait 系统调用会使父进程暂停执行，直到它的一个子进程结束为止。waitpid 则可以加入 <code>WNOHANG</code>  (wait-no-hang) 选项，如果没有发现结束的子进程，就会立即返回，不会将调用 waitpid 的进程阻塞。同时，waitpid 还可以选择是等待任一子进程（同 wait），还是等待指定 pid 的子进程，还是等待同一进程组下的任一子进程，还是等待组 ID 等于 pid 的任一子进程；</li>\n<li>子进程结束时，系统会产生 <code>SIGCHLD</code>  (signal-child) 信号，可以注册一个信号处理函数，在该函数中调用 waitpid，等待所有结束的子进程（注意：一般都需要循环调用 waitpid，因为在信号处理函数开始执行之前，可能已经有多个子进程结束了，而信号处理函数只执行一次，所以要循环调用将所有结束的子进程回收）；</li>\n<li>也可以用 <code>signal(SIGCLD, SIG_IGN)</code> (signal-ignore) 通知内核，表示忽略 <code>SIGCHLD</code>  信号，那么子进程结束后，内核会进行回收。</li>\n</ul>\n<h5 id=\"什么是孤儿进程\"><a class=\"anchor\" href=\"#什么是孤儿进程\">#</a> 什么是孤儿进程？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</p>\n<p>一个父进程已经结束了，但是它的子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程会被 Init（进程 ID 为 1）接管，当这些孤儿进程结束时由 Init 完成状态收集工作。<br />\n&lt;/details&gt;</p>\n<h3 id=\"线程同步有哪些方式\"><a class=\"anchor\" href=\"#线程同步有哪些方式\">#</a> 线程同步有哪些方式？</h3>\n<blockquote>\n<p>为什么需要线程同步：线程有时候会和其他线程共享一些资源，比如内存、数据库等。当多个线程同时读写同一份共享资源的时候，可能会发生冲突。因此需要线程的同步，多个线程按顺序访问资源。</p>\n</blockquote>\n<ul>\n<li><strong>互斥量</strong> Mutex：互斥量是内核对象，只有拥有互斥对象的线程才有访问互斥资源的权限。因为互斥对象只有一个，所以可以保证互斥资源不会被多个线程同时访问；当前拥有互斥对象的线程处理完任务后必须将互斥对象交出，以便其他线程访问该资源；</li>\n<li><strong>信号量</strong> Semaphore：信号量是内核对象，它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。信号量对象保存了<strong>最大资源计数</strong>和<strong>当前可用资源计数</strong>，每增加一个线程对共享资源的访问，当前可用资源计数就减 1，只要当前可用资源计数大于 0，就可以发出信号量信号，如果为 0，则将线程放入一个队列中等待。线程处理完共享资源后，应在离开的同时通过 <code>ReleaseSemaphore</code>  函数将当前可用资源数加 1。如果信号量的取值只能为 0 或 1，那么信号量就成为了互斥量；</li>\n<li><strong>事件</strong> Event：允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。事件分为手动重置事件和自动重置事件。手动重置事件被设置为激发状态后，会唤醒所有等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激发状态。自动重置事件被设置为激发状态后，会唤醒<strong>一个</strong>等待中的线程，然后自动恢复为未激发状态。</li>\n<li><strong>临界区</strong> Critical Section：任意时刻只允许一个线程对临界资源进行访问。拥有临界区对象的线程可以访问该临界资源，其它试图访问该资源的线程将被挂起，直到临界区对象被释放。</li>\n</ul>\n<h5 id=\"互斥量和临界区有什么区别\"><a class=\"anchor\" href=\"#互斥量和临界区有什么区别\">#</a> 互斥量和临界区有什么区别？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</p>\n<p>互斥量是可以命名的，可以用于不同进程之间的同步；而临界区只能用于同一进程中线程的同步。创建互斥量需要的资源更多，因此临界区的优势是速度快，节省资源。<br />\n&lt;/details&gt;</p>\n<h3 id=\"什么是协程\"><a class=\"anchor\" href=\"#什么是协程\">#</a> 什么是协程？</h3>\n<p>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p>\n<h5 id=\"协程与线程进行比较\"><a class=\"anchor\" href=\"#协程与线程进行比较\">#</a> 协程与线程进行比较？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</p>\n<ol>\n<li>\n<p>一个线程可以拥有多个协程，一个进程也可以单独拥有多个协程，这样 python 中则能使用多核 CPU。</p>\n</li>\n<li>\n<p>线程进程都是同步机制，而协程则是异步</p>\n</li>\n<li>\n<p>协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态<br />\n &lt;/details&gt;</p>\n</li>\n</ol>\n<h3 id=\"进程的异常控制流陷阱-中断-异常和信号\"><a class=\"anchor\" href=\"#进程的异常控制流陷阱-中断-异常和信号\">#</a> 进程的异常控制流：陷阱、中断、异常和信号</h3>\n<p>陷阱是<strong>有意</strong>造成的 “异常”，是执行一条指令的结果。陷阱是同步的。陷阱的主要作用是实现<strong>系统调用</strong>。比如，进程可以执行  <code>syscall n</code>  指令向内核请求服务。当进程执行这条指令后，会中断当前的控制流，<strong>陷入</strong>到内核态，执行相应的系统调用。内核的处理程序在执行结束后，会将结果返回给进程，同时退回到用户态。进程此时继续执行<strong>下一条指令</strong>。</p>\n<p>中断由处理器<strong>外部</strong>的<strong>硬件</strong>产生，不是执行某条指令的结果，也无法预测发生时机。由于中断独立于当前执行的程序，因此中断是异步事件。中断包括 I/O 设备发出的 I/O 中断、各种定时器引起的时钟中断、调试程序中设置的断点等引起的调试中断等。</p>\n<p>异常是一种错误情况，是执行当前指令的结果，可能被错误处理程序修正，也可能直接终止应用程序。异常是同步的。这里特指因为执行当前指令而产生的<strong>错误情况</strong>，比如除法异常、缺页异常等。有些书上为了区分，也将这类 “异常” 称为 **“故障”**。</p>\n<p>信号是一种<strong>更高层的</strong>软件形式的异常，同样会中断进程的控制流，可以由进程进行处理。一个信号代表了一个消息。信号的作用是用来<strong>通知进程</strong>发生了某种系统事件。</p>\n<p>更详细的可以参考：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9pbWFnZXNsci5naXRodWIuaW8vMjAyMC8wNy8wOS90cmFwLWludGVycnVwdC1leGNlcHRpb24uaHRtbA==\">https://imageslr.github.io/2020/07/09/trap-interrupt-exception.html</span></p>\n<h3 id=\"什么是io多路复用怎么实现\"><a class=\"anchor\" href=\"#什么是io多路复用怎么实现\">#</a> 什么是 IO 多路复用？怎么实现？</h3>\n<p>IO 多路复用（IO Multiplexing）是指单个进程 / 线程就可以同时处理多个 IO 请求。</p>\n<p>实现原理：用户将想要监视的文件描述符（File Descriptor）添加到 select/poll/epoll 函数中，由内核监视，函数阻塞。一旦有文件描述符就绪（读就绪或写就绪），或者超时（设置 timeout），函数就会返回，然后该进程可以进行相应的读 / 写操作。</p>\n<p>&lt;details&gt;<br />\n&lt;summary&gt;select/poll/epoll 三者的区别？&lt;/summary&gt;</p>\n<ul>\n<li><code>select</code> ：将文件描述符放入一个集合中，调用 select 时，将这个集合从用户空间拷贝到内核空间（缺点 1：每次都要复制，<strong>开销大</strong>），由内核根据就绪状态修改该集合的内容。（缺点 2）<strong>集合大小有限制</strong>，32 位机默认是 1024（64 位：2048）；采用水平触发机制。select 函数返回后，需要通过遍历这个集合，找到就绪的文件描述符（缺点 3：<strong>轮询的方式效率较低</strong>），当文件描述符的数量增加时，效率会线性下降；</li>\n<li><code>poll</code> ：和 select 几乎没有区别，区别在于文件描述符的存储方式不同，poll 采用链表的方式存储，没有最大存储数量的限制；</li>\n<li><code>epoll</code> ：通过内核和用户空间共享内存，避免了不断复制的问题；支持的同时连接数上限很高（1G 左右的内存支持 10W 左右的连接数）；文件描述符就绪时，采用回调机制，避免了轮询（回调函数将就绪的描述符添加到一个链表中，执行 epoll_wait 时，返回这个链表）；支持水平触发和边缘触发，采用边缘触发机制时，只有活跃的描述符才会触发回调函数。</li>\n</ul>\n<p>总结，区别主要在于：</p>\n<ul>\n<li>一个线程 / 进程所能打开的最大连接数</li>\n<li>文件描述符传递方式（是否复制）</li>\n<li>水平触发 or 边缘触发</li>\n<li>查询就绪的描述符时的效率（是否轮询）<br />\n&lt;/details&gt;</li>\n</ul>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 什么时候使用 select/poll，什么时候使用 epoll？&lt;/summary&gt;</p>\n<p>当连接数较多并且有很多的不活跃连接时，epoll 的效率比其它两者高很多；但是当连接数较少并且都十分活跃的情况下，由于 epoll 需要很多回调，因此性能可能低于其它两者。<br />\n&lt;/details&gt;</p>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 什么是文件描述符？&lt;/summary&gt;</p>\n<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p>\n<p>内核通过文件描述符来访问文件。文件描述符指向一个文件。<br />\n&lt;/details&gt;</p>\n<h5 id=\"什么是水平触发什么是边缘触发\"><a class=\"anchor\" href=\"#什么是水平触发什么是边缘触发\">#</a> 什么是水平触发？什么是边缘触发？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</p>\n<ul>\n<li>水平触发（LT，Level Trigger）模式下，只要一个文件描述符就绪，就会触发通知，如果用户程序没有一次性把数据读写完，下次还会通知；</li>\n<li>边缘触发（ET，Edge Trigger）模式下，当描述符从未就绪变为就绪时通知一次，之后不会再通知，直到再次从未就绪变为就绪（缓冲区从不可读 / 写变为可读 / 写）。</li>\n<li>区别：边缘触发效率更高，减少了被重复触发的次数，函数不会返回大量用户程序可能不需要的文件描述符。</li>\n<li>为什么边缘触发一定要用非阻塞（non-block）IO：避免由于一个描述符的阻塞读 / 阻塞写操作让处理其它描述符的任务出现饥饿状态。<br />\n&lt;/details&gt;</li>\n</ul>\n<h5 id=\"有哪些常见的io模型\"><a class=\"anchor\" href=\"#有哪些常见的io模型\">#</a> 有哪些常见的 IO 模型？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</p>\n<ul>\n<li>同步阻塞 IO（Blocking IO）：用户线程发起 IO 读 / 写操作之后，线程阻塞，直到可以开始处理数据；对 CPU 资源的利用率不够；</li>\n<li>同步非阻塞 IO（Non-blocking IO）：发起 IO 请求之后可以立即返回，如果没有就绪的数据，需要不断地发起 IO 请求直到数据就绪；不断重复请求消耗了大量的 CPU 资源；</li>\n<li>IO 多路复用</li>\n<li>异步 IO（Asynchronous IO）：用户线程发出 IO 请求之后，继续执行，由内核进行数据的读取并放在用户指定的缓冲区内，在 IO 完成之后通知用户线程直接使用。<br />\n&lt;/details&gt;</li>\n</ul>\n<h3 id=\"什么是用户态和内核态\"><a class=\"anchor\" href=\"#什么是用户态和内核态\">#</a> 什么是用户态和内核态？</h3>\n<p>为了限制不同程序的访问能力，防止一些程序访问其它程序的内存数据，CPU 划分了用户态和内核态两个权限等级。</p>\n<ul>\n<li>用户态只能受限地访问内存，且不允许访问外围设备，没有占用 CPU 的能力，CPU 资源可以被其它程序获取；</li>\n<li>内核态可以访问内存所有数据以及外围设备，也可以进行程序的切换。</li>\n</ul>\n<p>所有用户程序都运行在用户态，但有时需要进行一些内核态的操作，比如从硬盘或者键盘读数据，这时就需要进行系统调用，使用<strong>陷阱指令</strong>，CPU 切换到内核态，执行相应的服务，再切换为用户态并返回系统调用的结果。</p>\n<h5 id=\"为什么要分用户态和内核态\"><a class=\"anchor\" href=\"#为什么要分用户态和内核态\">#</a> 为什么要分用户态和内核态？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</p>\n<p>（我自己的见解：）</p>\n<ul>\n<li>安全性：防止用户程序恶意或者不小心破坏系统 / 内存 / 硬件资源；</li>\n<li>封装性：用户程序不需要实现更加底层的代码；</li>\n<li>利于调度：如果多个用户程序都在等待键盘输入，这时就需要进行调度；统一交给操作系统调度更加方便。<br />\n&lt;/details&gt;</li>\n</ul>\n<h5 id=\"如何从用户态切换到内核态\"><a class=\"anchor\" href=\"#如何从用户态切换到内核态\">#</a> 如何从用户态切换到内核态？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</p>\n<ul>\n<li>系统调用：比如读取命令行输入。本质上还是通过中断实现</li>\n<li>用户程序发生异常时：比如缺页异常</li>\n<li>外围设备的中断：外围设备完成用户请求的操作之后，会向 CPU 发出中断信号，这时 CPU 会转去处理对应的中断处理程序<br />\n &lt;/details&gt;</li>\n</ul>\n<h3 id=\"什么是死锁\"><a class=\"anchor\" href=\"#什么是死锁\">#</a> 什么是死锁？</h3>\n<p>在两个或者多个并发进程中，每个进程持有某种资源而又等待其它进程释放它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁 (deadlock)。</p>\n<h3 id=\"死锁产生的必要条件\"><a class=\"anchor\" href=\"#死锁产生的必要条件\">#</a> 死锁产生的必要条件？</h3>\n<ul>\n<li><strong>互斥</strong>：一个资源一次只能被一个进程使用；</li>\n<li><strong>占有并等待</strong>：一个进程至少占有一个资源，并在等待另一个被其它进程占用的资源；</li>\n<li><strong>非抢占</strong>：已经分配给一个进程的资源不能被强制性抢占，只能由进程完成任务之后自愿释放；</li>\n<li><strong>循环等待</strong>：若干进程之间形成一种头尾相接的环形等待资源关系，该环路中的每个进程都在等待下一个进程所占有的资源。</li>\n</ul>\n<h3 id=\"死锁有哪些处理方法\"><a class=\"anchor\" href=\"#死锁有哪些处理方法\">#</a> 死锁有哪些处理方法？</h3>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 鸵鸟策略 &lt;/summary&gt;</p>\n<p>直接忽略死锁。因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。<br />\n&lt;/details&gt;</p>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 死锁预防 &lt;/summary&gt;</p>\n<p>基本思想是破坏形成死锁的四个必要条件：</p>\n<ul>\n<li>破坏互斥条件：允许某些资源同时被多个进程访问。但是有些资源本身并不具有这种属性，因此这种方案实用性有限；</li>\n<li>破坏占有并等待条件：\n<ul>\n<li>实行资源预先分配策略（当一个进程开始运行之前，必须一次性向系统申请它所需要的全部资源，否则不运行）；</li>\n<li>或者只允许进程在没有占用资源的时候才能申请资源（申请资源前先释放占有的资源）；</li>\n<li>缺点：很多时候无法预知一个进程所需的全部资源；同时，会降低资源利用率，降低系统的并发性；</li>\n</ul>\n</li>\n<li>破坏非抢占条件：允许进程强行抢占被其它进程占有的资源。会降低系统性能；</li>\n<li>破坏循环等待条件：对所有资源统一编号，所有进程对资源的请求必须按照序号递增的顺序提出，即只有占有了编号较小的资源才能申请编号较大的资源。这样避免了占有大号资源的进程去申请小号资源。<br />\n&lt;/details&gt;</li>\n</ul>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 死锁避免 &lt;/summary&gt;</p>\n<p>动态地检测资源分配状态，以确保系统处于安全状态，只有处于安全状态时才会进行资源的分配。所谓安全状态是指：即使所有进程突然请求需要的所有资源，也能存在某种对进程的资源分配顺序，使得每一个进程运行完毕。</p>\n<blockquote>\n<p>银行家算法<br />\n &lt;/details&gt;</p>\n</blockquote>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 死锁解除 &lt;/summary&gt;</p>\n<blockquote>\n<p>如何检测死锁：检测有向图是否存在环；或者使用类似死锁避免的检测算法。</p>\n</blockquote>\n<p>死锁解除的方法：</p>\n<ul>\n<li>利用抢占：挂起某些进程，并抢占它的资源。但应防止某些进程被长时间挂起而处于饥饿状态；</li>\n<li>利用回滚：让某些进程回退到足以解除死锁的地步，进程回退时自愿释放资源。要求系统保持进程的历史信息，设置还原点；</li>\n<li>利用杀死进程：强制杀死某些进程直到死锁解除为止，可以按照优先级进行。<br />\n&lt;/details&gt;</li>\n</ul>\n<h3 id=\"分页和分段有什么区别\"><a class=\"anchor\" href=\"#分页和分段有什么区别\">#</a> 分页和分段有什么区别？</h3>\n<ul>\n<li>页式存储：用户空间划分为大小相等的部分称为页（page），内存空间划分为同样大小的区域称为页框，分配时以页为单位，按进程需要的页数分配，逻辑上相邻的页物理上不一定相邻；</li>\n<li>段式存储：用户进程地址空间按照自身逻辑关系划分为若干个段（segment）（如代码段，数据段，堆栈段），内存空间被动态划分为长度不同的区域，分配时以段为单位，每段在内存中占据连续空间，各段可以不相邻；</li>\n<li>段页式存储：用户进程先按段划分，段内再按页划分，内存划分和分配按页。</li>\n</ul>\n<p>区别：</p>\n<ul>\n<li>目的不同：分页的目的是管理内存，用于虚拟内存以获得更大的地址空间；分段的目的是满足用户的需要，使程序和数据可以被划分为逻辑上独立的地址空间；</li>\n<li>大小不同：段的大小不固定，由其所完成的功能决定；页的大小固定，由系统决定；</li>\n<li>地址空间维度不同：分段是二维地址空间（段号 + 段内偏移），分页是一维地址空间（每个进程一个页表 / 多级页表，通过一个逻辑地址就能找到对应的物理地址）；</li>\n<li>分段便于信息的保护和共享；分页的共享收到限制；</li>\n<li>碎片：分段没有内碎片，但会产生外碎片；分页没有外碎片，但会产生内碎片（一个页填不满）</li>\n</ul>\n<h3 id=\"什么是虚拟内存\"><a class=\"anchor\" href=\"#什么是虚拟内存\">#</a> 什么是虚拟内存？</h3>\n<p>每个程序都拥有自己的地址空间，这个地址空间被分成大小相等的页，这些页被映射到物理内存；但不需要所有的页都在物理内存中，当程序引用到不在物理内存中的页时，由操作系统将缺失的部分装入物理内存。这样，对于程序来说，逻辑上似乎有很大的内存空间，只是实际上有一部分是存储在磁盘上，因此叫做虚拟内存。</p>\n<p>虚拟内存的优点是让程序可以获得更多的可用内存。</p>\n<p>虚拟内存的实现方式、页表 / 多级页表、缺页中断、不同的页面淘汰算法：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9pbWFnZXNsci5naXRodWIuaW8vMjAyMC8wNy8wOC90ZWNoLWludGVydmlldy5odG1sI3ZpcnR1YWwtbWVtb3J5\">答案</span>。</p>\n<h5 id=\"如何进行地址空间到物理内存的映射\"><a class=\"anchor\" href=\"#如何进行地址空间到物理内存的映射\">#</a> 如何进行地址空间到物理内存的映射？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</p>\n<p><strong>内存管理单元</strong>（MMU）管理着逻辑地址和物理地址的转换，其中的页表（Page table）存储着页（逻辑地址）和页框（物理内存空间）的映射表，页表中还包含包含有效位（是在内存还是磁盘）、访问位（是否被访问过）、修改位（内存中是否被修改过）、保护位（只读还是可读写）。逻辑地址：页号 + 页内地址（偏移）；每个进程一个页表，放在内存，页表起始地址在 PCB / 寄存器中。<br />\n&lt;/details&gt;</p>\n<h3 id=\"有哪些页面置换算法\"><a class=\"anchor\" href=\"#有哪些页面置换算法\">#</a> 有哪些页面置换算法？</h3>\n<p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘中来腾出空间。页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p>\n<ul>\n<li><strong>最佳页面置换算法</strong> OPT（Optimal replacement algorithm）：置换以后不需要或者最远的将来才需要的页面，是一种理论上的算法，是最优策略；</li>\n<li><strong>先进先出</strong> FIFO：置换在内存中驻留时间最长的页面。缺点：有可能将那些经常被访问的页面也被换出，从而使缺页率升高；</li>\n<li><strong>第二次机会算法</strong> SCR：按 FIFO 选择某一页面，若其访问位为 1，给第二次机会，并将访问位置 0；</li>\n<li><strong>时钟算法</strong> Clock：SCR 中需要将页面在链表中移动（第二次机会的时候要将这个页面从链表头移到链表尾），时钟算法使用环形链表，再使用一个指针指向最老的页面，避免了移动页面的开销；</li>\n<li><strong>最近未使用算法</strong> NRU（Not Recently Used）：检查访问位 R、修改位 M，优先置换 R=M=0，其次是（R=0, M=1）；</li>\n<li><strong>最近最少使用算法</strong> LRU（Least Recently Used）：置换出未使用时间最长的一页；实现方式：维护时间戳，或者维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</li>\n<li><strong>最不经常使用算法</strong> LFU（Least Frequently Used）：置换出访问次数最少的页面</li>\n</ul>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 局部性原理 &lt;/summary&gt;</p>\n<ul>\n<li>时间上：最近被访问的页在不久的将来还会被访问；</li>\n<li>空间上：内存中被访问的页周围的页也很可能被访问。<br />\n&lt;/details&gt;</li>\n</ul>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 什么是颠簸现象 &lt;/summary&gt;</p>\n<p>颠簸本质上是指频繁的页调度行为。进程发生缺页中断时必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸。内存颠簸的解决策略包括：</p>\n<ul>\n<li>修改页面置换算法；</li>\n<li>降低同时运行的程序的数量；</li>\n<li>终止该进程或增加物理内存容量。<br />\n&lt;/details&gt;</li>\n</ul>\n<h3 id=\"缓冲区溢出问题\"><a class=\"anchor\" href=\"#缓冲区溢出问题\">#</a> 缓冲区溢出问题</h3>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 什么是缓冲区溢出？&lt;/summary&gt;<br />\nC 语言使用运行时栈来存储过程信息。每个函数的信息存储在一个栈帧中，包括寄存器、局部变量、参数、返回地址等。C 对于数组引用不进行任何边界检查，因此<strong>对越界的数组元素的写操作会破坏存储在栈中的状态信息</strong>，这种现象称为缓冲区溢出。缓冲区溢出会破坏程序运行，也可以被用来进行攻击计算机，如使用一个指向攻击代码的指针覆盖返回地址。<br />\n&lt;/details&gt;</p>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 缓冲区溢出的防范方式 &lt;/summary&gt;</p>\n<p>防范缓冲区溢出攻击的机制有三种：随机化、栈保护和限制可执行代码区域。</p>\n<ul>\n<li>随机化：包括栈随机化（程序开始时在栈上分配一段随机大小的空间）和地址空间布局随机化（Address-Space Layout Randomization，ASLR，即每次运行时程序的不同部分，包括代码段、数据段、栈、堆等都会被加载到内存空间的不同区域），但只能增加攻击一个系统的难度，不能完全保证安全。</li>\n<li>栈保护：在每个函数的栈帧的局部变量和栈状态之间存储一个<strong>随机产生的</strong>特殊的值，称为金丝雀值（canary）。在恢复寄存器状态和函数返回之前，程序检测这个金丝雀值是否被改变了，如果是，那么程序异常终止。</li>\n<li>限制可执行代码区域：内存页的访问形式有三种：可读、可写、可执行，只有编译器产生的那部分代码所处的内存才是可执行的，其他页限制为只允许读和写。</li>\n</ul>\n<p>&lt;/details&gt;</p>\n<p>更详细的可以参考：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9pbWFnZXNsci5naXRodWIuaW8vMjAyMC8wNy8wOC90ZWNoLWludGVydmlldy5odG1sI3N0YWNrb3ZlcmZsb3c=\">https://imageslr.github.io/2020/07/08/tech-interview.html#stackoverflow</span></p>\n<h3 id=\"磁盘调度\"><a class=\"anchor\" href=\"#磁盘调度\">#</a> 磁盘调度</h3>\n<p>过程：磁头（找到对应的盘面）；磁道（一个盘面上的同心圆环，寻道时间）；扇区（旋转时间）。为减小寻道时间的调度算法：</p>\n<ul>\n<li>先来先服务</li>\n<li>最短寻道时间优先</li>\n<li>电梯算法：电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</li>\n</ul>\n<h3 id=\"参考\"><a class=\"anchor\" href=\"#参考\">#</a> 参考</h3>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9jMTAxNWY1ZmZhNzQ=\">进程间通信 IPC -- 简书</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3Rsb3ZleW91Xy9hcnRpY2xlL2RldGFpbHMvNzgzMDQyOTQ=\">面试 / 笔试第二弹 —— 操作系统面试问题集锦 - CSDN 博客</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxODk3MDM2MQ==\">线程同步与并发 - - SegmentFault</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL2JhaWppYWhhby5iYWlkdS5jb20vcz9pZD0xNjQxMTcyNDk0Mjg3Mzg4MDcwJmFtcDt3ZnI9c3BpZGVyJmFtcDtmb3I9cGM=\">彻底搞懂 epoll 高效运行的原理</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGlyb25nMjEvcC80MjEzMDI4Lmh0bWw=\">用户态与内核态的切换</span></li>\n</ul>\n<h3 id=\"待完成\"><a class=\"anchor\" href=\"#待完成\">#</a> 待完成</h3>\n<ul class=\"task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_0\" disabled=\"true\" /><label for=\"cbx_0\"> IPC</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_1\" disabled=\"true\" /><label for=\"cbx_1\"> 进程同步问题：生产者 - 消费者问题...</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_2\" disabled=\"true\" /><label for=\"cbx_2\"> 银行家算法</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_3\" disabled=\"true\" /><label for=\"cbx_3\"> 文件与文件系统、文件管理？<br />\n&lt;div&gt;<br />\n&lt;img src=&quot;_v_images/20191202162008435_14938.png&quot; width=540px&gt;&lt;/img&gt;<br />\n&lt;/div&gt;</label></li>\n</ul>\n",
            "tags": [
                "计算机",
                "操作系统"
            ]
        },
        {
            "id": "http://example.com/2022/06/15/Git-ComdLine-REST/",
            "url": "http://example.com/2022/06/15/Git-ComdLine-REST/",
            "title": "Git/RESTful API/命令行",
            "date_published": "2022-06-15T03:00:00.000Z",
            "content_html": "<h1 id=\"gitrestful-api命令行\"><a class=\"anchor\" href=\"#gitrestful-api命令行\">#</a> Git/RESTful API / 命令行</h1>\n<ul>\n<li><a href=\"#git\">Git</a>\n<ul>\n<li><a href=\"#git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4\">Git 常用命令</a></li>\n<li><a href=\"#git-%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86\">Git 标签管理</a></li>\n<li><a href=\"#git-%E6%92%A4%E9%94%80%E4%B8%8E%E5%9B%9E%E6%BB%9A\">Git 撤销与回滚</a></li>\n<li><a href=\"#git-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86\">Git 分支管理</a></li>\n</ul>\n</li>\n<li><a href=\"#restful-api\">RESTful API</a></li>\n<li><a href=\"#linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4\">Linux 常用命令</a></li>\n<li><a href=\"#%E5%8F%82%E8%80%83\">参考</a></li>\n</ul>\n<hr />\n<h2 id=\"git\"><a class=\"anchor\" href=\"#git\">#</a> Git</h2>\n<h4 id=\"git-常用命令\"><a class=\"anchor\" href=\"#git-常用命令\">#</a> Git 常用命令</h4>\n<ul>\n<li><code>git init</code></li>\n<li><code>git clone</code></li>\n<li><code>git remote add origin ***.git</code></li>\n<li><code>git push -u origin master</code></li>\n<li>推送到远程仓库的 dev 分支： <code>git push origin dev</code></li>\n<li><code>git log</code></li>\n<li><code>git log --graph --pretty=oneline --abbrev-commit</code></li>\n<li><code>git status</code></li>\n<li><code>git diff</code></li>\n<li><code>git add *</code></li>\n<li><code>git commit -m &quot;message&quot;</code></li>\n<li>commit 之后又改了一个小 bug，但是又不想增加一个 commit，可以用： <code>git commit --amend --no-edit</code> ，直接将改动添加到上一次的 commit 中</li>\n<li><code>git push</code></li>\n<li><code>git pull</code></li>\n<li><code>touch .gitignore</code></li>\n</ul>\n<h4 id=\"git-标签管理\"><a class=\"anchor\" href=\"#git-标签管理\">#</a> Git 标签管理</h4>\n<ul>\n<li>首先切换到需要打标签的分支上，然后使用 <code>git tag v1.0</code>  就可以在当前 commit 打上 v1.0 的标签</li>\n<li><code>git tag v1.0 commitID</code>  对特定 commit 打标签</li>\n<li>打标签时加上 message： <code>git tag -a &lt;tagname&gt; -m &quot;message&quot;</code></li>\n<li><code>git tag</code>  查看所有标签</li>\n<li><code>git show [tagname]</code>  查看标签详细信息</li>\n<li><code>git push origin &lt;tagname&gt;</code>  可以推送一个本地标签到远程仓库</li>\n<li><code>git push origin --tags</code>  可以推送全部未推送过的本地标签</li>\n<li><code>git tag -d &lt;tagname&gt;</code>  可以删除一个本地标签</li>\n<li><code>git push origin :refs/tags/&lt;tagname&gt;</code>  可以删除一个远程标签（先从本地删除）</li>\n</ul>\n<h4 id=\"git-撤销与回滚\"><a class=\"anchor\" href=\"#git-撤销与回滚\">#</a> Git 撤销与回滚</h4>\n<ul>\n<li><strong>暂存区</strong>： <code>git add</code>  之后 commit 之前存在的区域；<strong>工作区</strong>： <code>git commit</code>  之后存在的区域；<strong>远程仓库</strong>： <code>git push</code>  之后；</li>\n<li>作了修改，但还没 <code>git add</code> ，撤销到上一次提交： <code>git checkout -f -- filename</code> ； <code>git checkout -f -- .</code></li>\n<li>作了修改，并且已经 <code>git add</code> ，但还没 <code>git commit</code> ：\n<ul>\n<li>先将暂存区的修改撤销： <code>git reset HEAD filename</code> / <code>git reset HEAD</code> ；此时修改只存在于工作区，变为了 &quot;unstaged changes&quot;；</li>\n<li>再利用上面的 checkout 命令从工作区撤销修改</li>\n</ul>\n</li>\n<li><code>git add</code>  之后，作了修改，想丢弃这次修改： <code>git checkout -f --filename</code>  会回到最近一次 <code>git add</code></li>\n<li>作了修改，并且已经 <code>git commit</code>  了，想撤销这次的修改：\n<ul>\n<li><code>git revert commitID</code> . 其实， <code>git revert</code>  可以用来撤销任意一次的修改，不一定要是最近一次</li>\n<li><code>git reset --hard commitID</code> / <code>git reset --hard HEAD^</code> （HEAD 表示当前版本，几个 ^ 表示倒数第几个版本，倒数第 100 个版本可以用 HEAD~100）；参数 <code>--hard</code> ：强制将暂存区和工作区都同步到指定的版本</li>\n<li><code>git reset</code>  和 <code>git revert</code>  的区别是：reset 是用来回滚的，将 HEAD 的指针指向了想要回滚的版本，作为最新的版本，而后面的版本也都没有了；而 revert 只是用来撤销某一次更改，对之后的更改并没有影响</li>\n<li>然后再用 <code>git push -f</code>  提交到远程仓库</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"git-分支管理\"><a class=\"anchor\" href=\"#git-分支管理\">#</a> Git 分支管理</h4>\n<ul>\n<li>创建分支:  <code>git branch test</code></li>\n<li>切换分支:  <code>git checkout test</code></li>\n<li>创建并切换分支： <code>git checkout -b test</code></li>\n<li>将 test 分支的更改合并到 master 分支：先在 test 分支上 commit、push，再： <code>git checkout master</code> ;  <code>git merge test</code></li>\n<li>如果合并时产生冲突：先手动解决冲突，再合并</li>\n<li>删除分支： <code>git branch -d test</code></li>\n<li><code>git stash</code>\n<ul>\n<li>如果当前分支还有任务没有做完，也不想提交，但此时需要切换或者创建其它分支，就可以使用 stash 将当前分支的所有修改（包括暂存区）先储藏起来；然后就可以切换到其它分支</li>\n<li>在其它分支工作完成之后，首先切换回原来的分支，然后使用 <code>git stash list</code>  命令查看</li>\n<li>可以使用 <code>git stash apply &lt;stash number&gt;</code>  恢复之前储藏的工作现场，再使用 <code>git stash drop &lt;stash number&gt;</code>  删除掉储藏的内容</li>\n<li>也可以直接用 <code>git stash pop</code>  恢复并删除内容</li>\n</ul>\n</li>\n<li>如果在其它分支上做了一个修改（比如修复了一个 bug，这次修改有一个 commitID），想要将这次修改应用到当前分支上，可以使用： <code>git cherry-pick commitID</code> ，可以复制一个特定的提交到当前分支</li>\n</ul>\n<h2 id=\"restful-api\"><a class=\"anchor\" href=\"#restful-api\">#</a> RESTful API</h2>\n<p>REST 指 Representational State Transfer，可以翻译为 “表现层状态转化”</p>\n<h4 id=\"主要思想\"><a class=\"anchor\" href=\"#主要思想\">#</a> 主要思想</h4>\n<ul>\n<li>对网络上的所有资源，都有一个<strong>统一资源标识符</strong> URI (Uniform Resource Identifier)；</li>\n<li>这些资源可以有多种表现形式，即 REST 中的 “表现层” Representation，比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现。URI 只代表资源的实体，不代表它的形式；</li>\n<li>“无状态 (Stateless)” 思想：服务端不应该保存客户端状态，只需要处理当前的请求，不需了解请求的历史，客户端每一次请求中包含处理该请求所需的一切信息；</li>\n<li>客户端使用 HTTP 协议中的 GET/POST/PUT/DELETE 方法对服务器的资源进行操作，即 REST 中的” 状态转化 “</li>\n</ul>\n<h4 id=\"设计原则\"><a class=\"anchor\" href=\"#设计原则\">#</a> 设计原则</h4>\n<ul>\n<li>URL 设计\n<ul>\n<li>最好只使用名词，而使用 GET/POST/PUT/DELETE 方法的不同表示不同的操作；比如使用 <code>POST /user</code>  代替 <code>/user/create</code></li>\n<li>GET：获取资源；POST：新建 / 更新资源；PUT：更新资源；DELETE：删除资源；</li>\n<li>对于只支持 GET/POST 的客户端，使用 <code>X-HTTP-Method-Override</code>  属性，覆盖 POST 方法；</li>\n<li>避免多级 URL，比如使用 <code>GET /authors/12?categories=2</code>  代替 <code>GET /authors/12/categories/2</code> ；</li>\n<li>避免在 URI 中带上版本号。不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个 URI，版本号可以在 HTTP 请求头信息的 Accept 字段中进行区分</li>\n</ul>\n</li>\n<li>状态码：服务器应该返回尽可能精确的状态码，客户端只需查看状态码，就可以判断出发生了什么情况。见计算机网络部分 -- <a href=\"Computer%20Network.md#HTTP%E8%AF%B7%E6%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81\">HTTP 请求有哪些常见状态码？</a></li>\n<li>服务器回应：在响应中放上其它 API 的链接，方便用户寻找</li>\n</ul>\n<h2 id=\"linux-常用命令\"><a class=\"anchor\" href=\"#linux-常用命令\">#</a> Linux 常用命令</h2>\n<h3 id=\"参考\"><a class=\"anchor\" href=\"#参考\">#</a> 参考</h3>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9sZWFybmdpdGJyYW5jaGluZy5qcy5vcmcvP2RlbW89JmFtcDtsb2NhbGU9emhfQ04=\">Learn Git Branching - 可视化的学习 Git 操作</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvODk2MDQzNDg4MDI5NjAw\">Git 教程 - 廖雪峰的官方网站</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTgvMTAvcmVzdGZ1bC1hcGktYmVzdC1wcmFjdGljZXMuaHRtbA==\">RESTful API 最佳实践 - 阮一峰的网络日志</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2psZXZ5L3RoZS1hcnQtb2YtY29tbWFuZC1saW5lL2Jsb2IvbWFzdGVyL1JFQURNRS16aC5tZA==\">GitHub - jlevy/the-art-of-command-line: Master the command line, in one page</span></li>\n</ul>\n",
            "tags": [
                "计算机",
                "命令"
            ]
        },
        {
            "id": "http://example.com/2022/06/01/Design%20Pattern/",
            "url": "http://example.com/2022/06/01/Design%20Pattern/",
            "title": "设计模式",
            "date_published": "2022-06-01T03:00:00.000Z",
            "content_html": "<h1 id=\"设计模式\"><a class=\"anchor\" href=\"#设计模式\">#</a> 设计模式</h1>\n<h2 id=\"设计模式是什么\"><a class=\"anchor\" href=\"#设计模式是什么\">#</a> 设计模式是什么</h2>\n<p>设计模式是一个通过定义、使用、测试去解决特定问题的方法，是针对软件设计中在给定条件下会重复性发生的问题而提出的一种通用性的可重用解决方案，设计模式不是可以直接转化为代码的完整设计，它是用于描述在不同情况下解决问题的通用方案。</p>\n<h2 id=\"设计模式的作用\"><a class=\"anchor\" href=\"#设计模式的作用\">#</a> 设计模式的作用</h2>\n<p>设计模式通过提供经过验证的行之有效的开发范式加快开发过程，预防重大的隐患问题，提高代码可读性。</p>\n<h2 id=\"设计模式的分类\"><a class=\"anchor\" href=\"#设计模式的分类\">#</a> 设计模式的分类</h2>\n<p><strong>这里主要讨论 GoF 所提出的 23 种设计模式，可将其分为三种类型：</strong></p>\n<ol>\n<li>创造型设计模式</li>\n<li>结构型设计模式</li>\n<li>行为型设计模式</li>\n</ol>\n<h3 id=\"创造型设计模式\"><a class=\"anchor\" href=\"#创造型设计模式\">#</a> 创造型设计模式</h3>\n<p>注重完成对象的实例化，相比于直接实例化对象，根据实际情况选择合适的设计模式完成对象的实例化，可以为复杂的业务场景带来更高的灵活性。<br />\n创造型设计模式主要包括以下几种：</p>\n<ol>\n<li>抽象工厂设计模式</li>\n<li>生成器设计模式</li>\n<li>工厂方法设计模式</li>\n<li>原型设计模式</li>\n<li>单例设计模式</li>\n</ol>\n<h3 id=\"结构型设计模式\"><a class=\"anchor\" href=\"#结构型设计模式\">#</a> 结构型设计模式</h3>\n<p>结构型设计模式用于指导我们完成对代码的结构划分，如此，代码结构会更加清晰，更易理解，也提高了软件的可维护性。<br />\n结构型设计模式主要包括以下几种：</p>\n<ol>\n<li>适配器设计模式</li>\n<li>桥接设计模式</li>\n<li>组合设计模式</li>\n<li>装饰设计模式</li>\n<li>门面设计模式</li>\n<li>享元设计模式</li>\n<li>代理设计模式</li>\n</ol>\n<h3 id=\"行为型设计模式\"><a class=\"anchor\" href=\"#行为型设计模式\">#</a> 行为型设计模式</h3>\n<p>行为型设计模式主要用于定义对象之间的通信与流程控制，主要的设计模式都非常注重优化对象之间的数据交互方式。<br />\n行为型设计模式主要包括以下几种：</p>\n<ol>\n<li>职责链设计模式</li>\n<li>命令设计模式</li>\n<li>解释器设计模式</li>\n<li>迭代器设计模式</li>\n<li>中介者设计模式</li>\n<li>备忘录设计模式</li>\n<li>观察者设计模式</li>\n<li>策略设计模式</li>\n<li>状态设计模式</li>\n<li>模板方法设计模式</li>\n<li>访问者设计模式</li>\n</ol>\n<h2 id=\"如何学习设计模式\"><a class=\"anchor\" href=\"#如何学习设计模式\">#</a> 如何学习设计模式</h2>\n<ul>\n<li>模式名称是什么？</li>\n<li>模式类型是什么？是创造型，结构型，还是行为型？</li>\n<li>模式的目的是什么？（作用是什么？解决了什么问题？）</li>\n<li>模式的别名是什么？</li>\n<li>什么情况下使用该模式？</li>\n<li>该模式的基本示例</li>\n<li>该模式的 UML 图是什么样的？是类图还是交互图？</li>\n<li>都有那些对象在模式中参与活动？列出设计模式中使用的类和对象，并说明他们各自的角色</li>\n<li>模式中的类和对象是怎么进行交互的？</li>\n<li>通过应用设计模式能获取什么好处，有哪些坏处？如何权衡？</li>\n<li>如何实现该模式</li>\n<li>与该模式相近的设计模式是什么？这几种相近的模式有哪些异同点？</li>\n</ul>\n<h2 id=\"正确看待设计模式\"><a class=\"anchor\" href=\"#正确看待设计模式\">#</a> 正确看待设计模式</h2>\n<p>恰当使用设计模式能够提高代码的复用性，但是由于复用性往往会引入封装与间接调用，这些会降低系统性能，增加代码复杂程度。因此，除非设计模式能够帮助我们完成代码的实现或者后续的维护工作，否则没有必要去引入设计模式。<br />\n学习设计模式的关键并不在于学习设计模式本身，而是在于识别应用场景与潜在的风险，并将设计模式用之有道，这般，设计模式才能算作得心应手的工具。<br />\n在没有必要的情况大可不必去使用设计模式，因为设计模式有可能会牺牲代码的简洁性，而且滥用设计模式多会引入新的问题却没有解决原来的问题。<br />\n<strong>保持代码的整洁，模块化和可读性，同时不要让各类之间过度耦合。</strong></p>\n<h2 id=\"创造型设计模式-2\"><a class=\"anchor\" href=\"#创造型设计模式-2\">#</a> 创造型设计模式</h2>\n<p>创造型设计模式主要关注的是类的实例化，也就是说体现的是对象的创建方法，利用这些模式，我们可以在适当的情况下以适当的形式创建对象，创造型设计模式通过控制对象的创建来解决设计中的问题。<br />\n创造型设计模式主要包含以下子类别：</p>\n<ol>\n<li>对象创造型设计模式：</li>\n</ol>\n<p>主要完成对象创建，并将对象中部分内容放到其他对象中创建。</p>\n<ol start=\"2\">\n<li>类创造型设计模式：</li>\n</ol>\n<p>主要完成类的实例化，并将类中的部分对象放到子类中创建，此类模式在实例化过程中高效地利用了继承机制<br />\n创造型设计模式主要包含以下 5 种具体的设计模式：</p>\n<ol>\n<li>抽象工厂设计模式</li>\n</ol>\n<p>提供一个用于创建相关对象或相互依赖对象的接口，无需指定对象的具体类</p>\n<ol start=\"2\">\n<li>生成器设计模式</li>\n</ol>\n<p>将复杂对象的构建与其表示相互分离，使得同样的构建过程可以创建不同的表示</p>\n<ol start=\"3\">\n<li>工厂方法设计模式</li>\n</ol>\n<p>允许在子类中实现本类的实例化类</p>\n<ol start=\"4\">\n<li>原型设计模式</li>\n</ol>\n<p>使用一个原型实例来指定创建对象的种类，然后通过拷贝这些原型实现新对象的创建</p>\n<ol start=\"5\">\n<li>单例模式</li>\n</ol>\n<p>确保某个类在系统中仅有一个实例，并提供一个访问它的全局访问点</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">对象创造型设计模式</th>\n<th style=\"text-align:center\">类创造型设计模式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">抽象工厂设计模式</td>\n<td style=\"text-align:center\">工厂方法设计模式</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">生成器设计模式</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">原型设计模式</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">单例设计模式</td>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"工厂方法设计模式\"><a class=\"anchor\" href=\"#工厂方法设计模式\">#</a> 工厂方法设计模式</h3>\n<p>工厂方法的作用是创建对象，用来从一组实现特定逻辑的类中实例化某个对象。</p>\n<h4 id=\"模式中包括的类\"><a class=\"anchor\" href=\"#模式中包括的类\">#</a> 模式中包括的类</h4>\n<ul>\n<li>产品类（Product）中定义了工厂方法创建的对象接口。</li>\n<li>具体产品类（ Concrete Product）实现产品类接口。</li>\n<li>工厂类（ Creator，因为由它来创建产品类，所以叫作工厂类）声明工厂方法，返回一个产品类对象。可用于调用创建产品类对象的生成方法。</li>\n<li>具体工厂类（ Concrete Creator）重写用于创建具体产品类对象的方法。</li>\n</ul>\n<h4 id=\"uml图\"><a class=\"anchor\" href=\"#uml图\">#</a> UML 图</h4>\n<p><img data-src=\"_v_images/1588679646408-22276075-76c2-42b2-8b20-84e3401fdbf7.png#align=left&amp;display=inline&amp;height=231&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=381&amp;originWidth=1228&amp;size=220064&amp;status=done&amp;style=none&amp;width=746\" alt=\"image.png\" /></p>\n<h4 id=\"功能及应用场景\"><a class=\"anchor\" href=\"#功能及应用场景\">#</a> 功能及应用场景</h4>\n<ul>\n<li>当需要创建一个类，而在编程时不能确定这个类的类型时（需要运行时确定）。</li>\n<li>当一个类希望由其子类来指定所创建对象的具体类型时。</li>\n<li>当我们想要定位被创建类，并获取相关信息时。</li>\n</ul>\n<h3 id=\"抽象工厂设计模式\"><a class=\"anchor\" href=\"#抽象工厂设计模式\">#</a> 抽象工厂设计模式</h3>\n<p>抽象工厂模式相比于工厂方法模式的抽象层次更高。这意味着抽象工厂返回的是一组类的工厂。与工厂方法模式类似（返回多个子类中的一个），此方法会返回一个工厂，而这个工厂会返回多个子类中的一个。简单来说，抽象工厂是一个工厂对象，该对象又会返回若干工厂中的一个。<br />\n工厂模式是创造型模式的典型示例。抽象工厂设计模式是工厂方法模式的扩展，从而使我们无须担心所创建对象的实际类就能够创建对象。抽象工厂模式扩展了工厂方法模式，允许创建更多类型的对象。</p>\n<h4 id=\"模式中包括的类-2\"><a class=\"anchor\" href=\"#模式中包括的类-2\">#</a> 模式中包括的类</h4>\n<ul>\n<li>抽象工厂（AbstractFactory）声明一个用于完成抽象产品对象创建操作的接口。</li>\n<li>具体工厂（ConcreteFactory）实现创建具体产品对象的操作。</li>\n<li>抽象产品（AbstractProduct）声明一个用于一类产品对象的接口。</li>\n<li>具体产品（ConcreteProduct）定义由相应的具体工厂来创建的产品对象。</li>\n<li>客户端（Client）使用由抽象工厂和抽象产品类声明的唯一接口。</li>\n</ul>\n<h4 id=\"uml图-2\"><a class=\"anchor\" href=\"#uml图-2\">#</a> UML 图</h4>\n<p><img data-src=\"_v_images/1588681690229-615d93e2-9429-42cc-812e-fa8cb7eb49a4.png#align=left&amp;display=inline&amp;height=307&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=565&amp;originWidth=1374&amp;size=368470&amp;status=done&amp;style=none&amp;width=746\" alt=\"image.png\" /></p>\n<h4 id=\"功能及应用场景-2\"><a class=\"anchor\" href=\"#功能及应用场景-2\">#</a> 功能及应用场景</h4>\n<p>抽象工厂模式的主要优点之一是它屏蔽了这些具体类的创建方法。实际应用的类名称不需要再让客户端（将客户端与具体类解耦）知道。由于具体类是屏蔽的，因此我们可以在不同的工厂（实现方法）之间进行切换。</p>\n<h3 id=\"生成器设计模式\"><a class=\"anchor\" href=\"#生成器设计模式\">#</a> 生成器设计模式</h3>\n<p>生成器模式，能够从简单的对象一步一步生成复杂的对象。生成器模式是一种用来逐步构建复杂对象并在最后一步返回对象的创造型模式。<br />\n构造一个对象的过程是通过泛型实现的，以便它能够用于对同一对象创建不同的表示形式。</p>\n<h4 id=\"模式中包括的类-3\"><a class=\"anchor\" href=\"#模式中包括的类-3\">#</a> 模式中包括的类</h4>\n<ul>\n<li>生成器类（ Builder）提供一个接口用于创建产品的各个组成部件。具体生成器（Concrete Builder）提供此接的实现。</li>\n<li>具体生成器（ ConcreteBuilder）会跟踪其所创建对象的表现形式，并在创建对象的同时提供一个接口获取产品（Product）。</li>\n<li>导演类（ Director）通过生成器提供的接口构造对象。产品类用于表示被构造的复杂对象。这包括对我们构建的所有类进行定义。</li>\n</ul>\n<h4 id=\"uml图-3\"><a class=\"anchor\" href=\"#uml图-3\">#</a> UML 图</h4>\n<p><img data-src=\"_v_images/1588687137859-38493900-8c93-43ef-bbe7-c67c14e9ba75.png#align=left&amp;display=inline&amp;height=286&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=364&amp;originWidth=951&amp;size=131071&amp;status=done&amp;style=none&amp;width=746\" alt=\"image.png\" /></p>\n<h4 id=\"功能及应用场景-3\"><a class=\"anchor\" href=\"#功能及应用场景-3\">#</a> 功能及应用场景</h4>\n<p>生成器模式隐藏了产品构建过程中的内部细节。各个生成器之间都是相互独立的。这提高了代码的模块化，并使其他的生成器更方便地创建对象。因为每个生成器都能够逐步创建对象，这让我们能够很好地对最终产品进行掌控。</p>\n<h3 id=\"单例设计模式\"><a class=\"anchor\" href=\"#单例设计模式\">#</a> 单例设计模式</h3>\n<p>在应用程序的整个生命周期中，对象只有一个实例的时候，就会使用单例设计模式。单例类总是在第一次被访问时完成实例化，直至应用程序退出之前，都只会使用同一个实例。单一实例创建策略：我们通过限制构造函数（通过设置其为私有）从而限制单例类的实例化。之后在定义类时包含一个该类的静态私有对象，以便创建单例类的实例。<br />\n在单例模式中，最棘手的部分是对单一实例的实现和管理。<br />\n在单例模式的定义过程中，有两点需要注意的地方：</p>\n<ul>\n<li>该类仅允许存在一个实例。</li>\n<li>需要为该单一实例提供一个全局访问点。</li>\n</ul>\n<p>单例模式中的主动实例化和被动实例化（饿汉、懒汉）<br />\n线程安全的单例：双重同步锁、静态变量、枚举</p>\n<h4 id=\"模式中包括的类-4\"><a class=\"anchor\" href=\"#模式中包括的类-4\">#</a> 模式中包括的类</h4>\n<ul>\n<li>单例类</li>\n</ul>\n<h4 id=\"uml图-4\"><a class=\"anchor\" href=\"#uml图-4\">#</a> UML 图</h4>\n<p><img data-src=\"_v_images/1588689300339-c33a3d0d-7544-4754-8695-b08fc843183d.png#align=left&amp;display=inline&amp;height=208&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=208&amp;originWidth=334&amp;size=51899&amp;status=done&amp;style=none&amp;width=334\" alt=\"image.png\" /></p>\n<h4 id=\"功能及应用场景-4\"><a class=\"anchor\" href=\"#功能及应用场景-4\">#</a> 功能及应用场景</h4>\n<p>在应用程序的整个生命周期中，对象只有一个实例的时候，就会使用单例设计模式。</p>\n<h3 id=\"原型设计模式\"><a class=\"anchor\" href=\"#原型设计模式\">#</a> 原型设计模式</h3>\n<p>相比于以往创建一个复杂对象总是费时费力，原型模式只需要复制现有的相似对象，并根据需要做适当修改。原型意味着使用克隆方法。克隆方法是一种复制对象的操作。克隆出的对象副本被初始化为调用克隆方法时原始对象的当前状态。这意味着对象的克隆避免了创建新对象。如果创建一个新对象的开销很大，而且有可能引起资源紧张时，我们就克隆对象。</p>\n<ul>\n<li>浅层复制：当原始对象变化时，新对象也跟着改变。这主要是因为浅层复制并没有实际复制新的对象，而只是对原有对象的一个引用。</li>\n<li>深层复制：当原始对象变化时，新对象不受影响，因为原始对象所包含的所有参数、对象和引用在复制新对象的过程中都建立了新的拷贝。</li>\n</ul>\n<p>使用克隆方法来复制对象时，具体是使用浅层复制还是深层复制是由业务需求来决定的。在使用原型模式时，使用克隆方法来复制对象仅仅是一个设计上的决策。克隆方法对于原型模式来说并不是强制性的最佳选择。</p>\n<h4 id=\"模式中包括的类-5\"><a class=\"anchor\" href=\"#模式中包括的类-5\">#</a> 模式中包括的类</h4>\n<ul>\n<li>客户端（Client）：通过调用原型类的克隆操作创建一个新对象。</li>\n<li>原型类（ Prototype）：声明一个接口用于克隆自己。</li>\n<li>具体原型类（ Concrete Prototype）：实现克隆自己的操作。</li>\n</ul>\n<h4 id=\"uml图-5\"><a class=\"anchor\" href=\"#uml图-5\">#</a> UML 图</h4>\n<p><img data-src=\"_v_images/1588746617916-a21ed08c-42df-40c0-bc79-6701209c2f55.png#align=left&amp;display=inline&amp;height=564&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=564&amp;originWidth=951&amp;size=191697&amp;status=done&amp;style=none&amp;width=951\" alt=\"image.png\" /></p>\n<h4 id=\"功能及应用场景-5\"><a class=\"anchor\" href=\"#功能及应用场景-5\">#</a> 功能及应用场景</h4>\n<ol>\n<li>当一个系统应该独立于其产品的创建、组合和表示。</li>\n<li>当需要实例化的类是在运行时定义的，例如动态加载，或避免建立一个平行于产品类继承层次的工厂类继承层次时。</li>\n<li>当一个类的实例仅可以拥有若干不同的状态组合中的一个时。使用原型模式建立相应数量的原型和克隆方法，会比每次都手动实例化类并配置相应状态更加方便。</li>\n</ol>\n<p><strong>主要难点：</strong></p>\n<ul>\n<li>每个原型类的子类都必须实现克隆操作。这实现起来可能有难度。例如，当类已经存在的时候添加克隆方法可能比较困难。</li>\n<li>对象内部包含其他不支持克隆的对象或具有循环引用的对象时，实现克隆方法会比较困难。</li>\n</ul>\n<p><strong>优点：</strong></p>\n<ul>\n<li>原型模式意味着使用克隆方法。克隆方法是一种复制对象的操作。相比于耗时的复制对象创建过程，原型模式仅复制类似的现有对象，再根据需要对复制出的副本进行修改。</li>\n<li>客户端可以在运行时添加或移除原型对象。</li>\n<li>通过各种参数来定义新对象：高度动态的系统允许我们通过使用对象组合来定义新的特征，例如为对象变量指定相应的参数值，而不是重新定义一个类。我们通过实例化现有类可以有效地定义新类型的对象，并为客户端对象注册原型实例。客户端可以通过向原型类委派某个责任而使其具有新的特征。这种设计允许用户无须大量编程就能轻松定义新的类。事实上，克隆一个原型本质上是类似于类的实例化的。但原型模式能够大大降低系统所需的类的数量。</li>\n</ul>\n<p><strong>副作用：</strong></p>\n<ul>\n<li>使用原型模式，我们可以根据需要通过对象克隆来实现运行时对象的添加和删除。我们可以根据程序运行情况在运行时修改类的内部数据表示形式。</li>\n<li>在 Java 中实现原型模式的一大困难是如果这些类已经存在，我们未必能够通过添加所需要的克隆方法或深层克隆方法对类进行修改。此外，那些与其他类具有循环引用关系的类并不能真正实现克隆。</li>\n<li>需要在这些类中具有足够的数据访问权限或方法，以便在克隆完成后对相应的数据进行修改。这可能需要在这些原型类中添加相应的数据访问方法，以便我们对类完成克隆之后可以修改数据。</li>\n</ul>\n<h2 id=\"结构型设计模式-2\"><a class=\"anchor\" href=\"#结构型设计模式-2\">#</a> 结构型设计模式</h2>\n<p>结构型模式主要描述如何将对象和类组合在一起以组成更复杂的结构。在软件工程中结构型模式是用于帮助设计人员通过简单的方式来识别和实现对象之间关系的设计模式。结构型模式会以组的形式组织程序。这种划分形式使代码更加清晰，维护更加简便。结构型模式用于代码和对象的结构组织。<br />\n结构型模式会以组的形式组织程序。这种划分形式使代码更加清晰，维护更加简便。<br />\n<strong>结构型模式又分为以下子类别：</strong></p>\n<ol>\n<li>对象结构型模式：用于对象之间相互关联与组织，以便形成更大、更复杂的结构。</li>\n<li>类结构型模式：用于实现基于继承的代码抽象，并且会介绍如何通过该模式提供更有用的程序接口。</li>\n</ol>\n<p><strong>具体包括：</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">对象结构型模式</th>\n<th style=\"text-align:center\">类结构型模式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">桥接模式</td>\n<td style=\"text-align:center\">类适配器模式</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">组合模式</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">装饰模式</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">门面模式</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">享元模式</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">对象适配器模式</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">代理模式</td>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li>组合模式：它能够为客户端处理各种复杂和灵活的树状结构。这些树结构可以由各种不同类型的容器和叶节点组成，其深度或组合形式能够在运行时调整或确定。</li>\n<li>装饰模式：允许我们通过附加新的功能或修改现有功能，在运行时动态地修改对象。</li>\n<li>门面模式：允许我们为客户端创建一个统一的接口以访问不同子系统的不同接口，从而简化客户端。</li>\n<li>享元模式：客户端调用类时会在运行时创建大量对象，该模式会重新设计类以优化内存开销。</li>\n<li>代理模式：为其他对象提供一种代理以控制对这个对象的访问。这种模式的目的是一个对象不适合或者不能直接引用另一个对象，简化客户端并实现对象访问，同时避免任何副作用。</li>\n<li>适配器模式：允许我们为一个已有的类提供一个新的接口，并在客户端请求不同接口时实现类的重用。</li>\n<li>桥接模式：允许我们将类与其接口相互解耦。允许类及其接口随着时间相互独立变化，增加类重用的次数，提高后续可扩展性。它也允许运行时对接口的不同实现方式动态切换，使代码更加灵活。</li>\n</ol>\n<h3 id=\"适配器设计模式\"><a class=\"anchor\" href=\"#适配器设计模式\">#</a> 适配器设计模式</h3>\n<p>软件适配器的工作原理也和插座适配器完全一样。我们也经常需要在程序中使用到不同的类或模块。假设有一段代码写得很烂，如果我们直接将这些代码集成到程序中，会将现有的代码搞乱。但是我们又不得不调用这段代码，因为我们需要实现相关的功能，而从头写起会耽误很多宝贵的时间。这时的最佳实践就是编写适配器，并将所需要的代码包装进去。这样我们就能够使用自定义的接口，从而降低对外部代码的依赖。<br />\n适配器模式会将现有接口转换为新的接口，已实现对应用程序中不相关的类的兼容性和可重用性的目标。适配器模式也被称为包装模式。适配器模式能够帮助那些因为接口不兼容而无法一起工作的类，以便它们能够一同工作。<br />\n适配器模式也负责将数据转换成适当的形式。当客户端在接口中指定了其对数据格式的要求时，我们通常可以创建新的类以实现现有类的接口和子类。这种实现方式也会通过创建类适配器，实现对客户端调用命和现有类中被调用方法之间接口的转换。</p>\n<h4 id=\"模式中包括的类-6\"><a class=\"anchor\" href=\"#模式中包括的类-6\">#</a> 模式中包括的类</h4>\n<ul>\n<li>客户端（Client）调用目标类的类或程序。</li>\n<li>目标类（Target）客户端想要使用的接口。</li>\n<li>适配对象类（Adapetee）需要进行适配的类或对象。</li>\n<li>适配器类（ Adapter）按照目标类接口的要求对适配对象接口实现接口形式的适配转换。</li>\n<li>request 方法：客户端想要执行的操作。</li>\n<li>specificRequest 方法：适配对象中能够完成 request 方法功能的实现。</li>\n</ul>\n<h4 id=\"uml图-6\"><a class=\"anchor\" href=\"#uml图-6\">#</a> UML 图</h4>\n<p><strong><img data-src=\"_v_images/1588761010089-ced9b3a9-3232-4729-943a-67c133909d7c.png#align=left&amp;display=inline&amp;height=395&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=395&amp;originWidth=1149&amp;size=182309&amp;status=done&amp;style=none&amp;width=1149\" alt=\"image.png\" /></strong></p>\n<h4 id=\"功能及应用场景-6\"><a class=\"anchor\" href=\"#功能及应用场景-6\">#</a> 功能及应用场景</h4>\n<p>在具体实践上，有两种实际应用适配器模式的方法：</p>\n<ol>\n<li>使用继承［类适配器］</li>\n<li>使用关联［对象适配器］</li>\n</ol>\n<p><strong>应用场景：</strong></p>\n<ul>\n<li>我们想要使用现有的类，但它的接口不符合我们的需要。</li>\n<li>我们想要创建一个可重用的类，能够与一些无关的类或不可预见的类进行协作，同时这个类无须具有兼容的接口。</li>\n<li>（仅适用于对象适配器）我们需要使用多个已经存在的子类，而我们为每一个子类都做接口适配显然是不切实际的。使用对象适配器可以直接适配其父类的接口。</li>\n</ul>\n<h3 id=\"桥接设计模式\"><a class=\"anchor\" href=\"#桥接设计模式\">#</a> 桥接设计模式</h3>\n<p>桥接模式是结构型模式中的另一个典型模式。桥接模式用于将类的接口与接口的实现相互解耦。这样做提高了系统的灵活性使得接口和实现两者均可独立变化。<br />\n举一个例子，让我们想一下家用电器及其开关。例如，风扇的开关。开关是电器的控制接口，而一旦闭合开关，实际让风扇运转的是风扇电机。<br />\n所以，在这个示例中，开关和风扇之间是彼此独立的。如果我们将开关接到电灯泡的供电线路上，那么我们还可以选用其他开关来控制风扇。</p>\n<h4 id=\"模式中包括的类-7\"><a class=\"anchor\" href=\"#模式中包括的类-7\">#</a> 模式中包括的类</h4>\n<ul>\n<li>抽象化对象（Abstraction）桥接设计模式的核心，并定义了关键症结所在。包含对实现化对象的引用。</li>\n<li>扩充抽象化对象（RefinedAbstraction）扩展抽象化对象，并将抽象化对象细化到新的层次。对实现化对象隐藏细节元素。</li>\n<li>实现化对象（Implementor）该接口比抽象化对象的层次更高。只对基本操作进行定义。</li>\n<li>具体实现化对象（Concretelmplementor）通过提供具体实现来执行实现化对象的具体功能。</li>\n</ul>\n<h4 id=\"uml图-7\"><a class=\"anchor\" href=\"#uml图-7\">#</a> UML 图</h4>\n<p><img data-src=\"_v_images/1588760917772-e4e10a15-0c43-456e-88f2-279fdd3e2d12.png#align=left&amp;display=inline&amp;height=411&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=411&amp;originWidth=1027&amp;size=184618&amp;status=done&amp;style=none&amp;width=1027\" alt=\"image.png\" /></p>\n<h4 id=\"功能及应用场景-7\"><a class=\"anchor\" href=\"#功能及应用场景-7\">#</a> 功能及应用场景</h4>\n<p>桥接模式主要适用于系统的多个维度上都经常发生变化的情况。桥接模式能够将不同的抽象维度进行衔接。通过桥接模式，抽象化对象和实现化对象不会在编译时进行绑定，而能够在各自的类被调用时独立扩展。<br />\n当你经常需要在运行时在多个实现之间进行切换时，桥接模式也非常有用。</p>\n<h3 id=\"组合设计模式\"><a class=\"anchor\" href=\"#组合设计模式\">#</a> 组合设计模式</h3>\n<p>在大部分系统开发过程中，程序员都会遇到某个组件既可以是独立的个体对象，也能够作为对象集合的情况。组合模式就用于此类情况的设计。简单来说，组合模式是一组对象的集合，而这组对象中的每一个对象本身也是一个组合模式构成的对象，或者只是一个原始对象。<br />\n组合模式中存在着一个树形结构，并且在该结构中的分支节点和叶节点上都能够执行相同的操作。树形结构中每一个分支节点都包含子节点的类（能继承出叶节点和分支节点），这样的分支节点本身就是一个组合模式构成的节点。树形结构中的叶子节点仅是一个原始对象，其没有子节点（不能继承出叶节点和分支节点）。组合模式的子类（下一级节点）可以是叶子节点或其他组合模式。</p>\n<h4 id=\"模式中包括的类-8\"><a class=\"anchor\" href=\"#模式中包括的类-8\">#</a> 模式中包括的类</h4>\n<ul>\n<li>组件对象：（Component，结构）\n<ul>\n<li>组件对象在整个继承结构的最顶端。它是对组合模式的抽象。</li>\n<li>它声明了组合模式中的对象接口。</li>\n<li>可以选择性地定义一个接口，以便对递归结构中组件的父类进行访问，并在需要的时候实现该接口。</li>\n</ul>\n</li>\n<li>叶子节点：（Leaf，原始对象）\n<ul>\n<li>树形结构的末端且不会再有子节点。</li>\n<li>定义了组合结构中单个对象的行为。</li>\n</ul>\n</li>\n<li>分支节点类：（Composite，组）\n<ul>\n<li>包含了子组件并为它们定义行为。</li>\n<li>实现子节点的相关操作。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"uml图-8\"><a class=\"anchor\" href=\"#uml图-8\">#</a> UML 图</h4>\n<p><img data-src=\"_v_images/1588762859910-c08b6230-8358-42e8-aa48-5835af2d2940.png#align=left&amp;display=inline&amp;height=395&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=395&amp;originWidth=1149&amp;size=182309&amp;status=done&amp;style=none&amp;width=1149\" alt=\"image.png\" /></p>\n<h4 id=\"功能及应用场景-8\"><a class=\"anchor\" href=\"#功能及应用场景-8\">#</a> 功能及应用场景</h4>\n<ul>\n<li>当对象的集合需要采用与单个对象相同的处理方式时。</li>\n<li>操纵单个对象的方式与操纵一组对象的方式类似时。</li>\n<li>注意存在能够组合的递归结构或树形结构。</li>\n<li>客户端能够通过组件对象访问整个继承结构，而它们却不会知道自己所处理的是叶子节点还是分支节点。</li>\n</ul>\n<p>组合模式的目的是能够使独立对象（单个分支节点或叶子节点）和对象集合（子树）都能够以同样的方式组织起来。组合模式中所有的对象都来自于其本身（成为一种嵌套结构）。组合模式允许我们使用递归的方式将类似的对象组合成一种树形结构，来实现复杂结构对象的构建。</p>\n<h3 id=\"装饰者设计模式\"><a class=\"anchor\" href=\"#装饰者设计模式\">#</a> 装饰者设计模式</h3>\n<p>装饰设计模式用来在运行时扩展或修改一个实例的功能。一般来说，继承可以扩展类的功能（用于类的所有实例）。但与继承不同的是，通过装饰模式，我们可以选择一个类的某个对象，并对其进行修改，而不会影响这个类中其他的实例。继承会直接为类增加功能，而装饰模式则会通过将对象与其他对象进行包装的方式将功能添加到类。</p>\n<h4 id=\"模式中包括的类-9\"><a class=\"anchor\" href=\"#模式中包括的类-9\">#</a> 模式中包括的类</h4>\n<ul>\n<li>抽象组件（Component）给出一个抽象接口，用于能够动态添加功能的对象。</li>\n<li>具体组件（Concrete Component）定义一个实现组件接口的对象。这是实际需要加以装饰的对象，但其对装饰的过程一无所知。</li>\n</ul>\n<h4 id=\"uml图-9\"><a class=\"anchor\" href=\"#uml图-9\">#</a> UML 图</h4>\n<p><img data-src=\"_v_images/1588776261625-d6b2f2b2-85c7-4752-ba71-ac38f9ca639c.png#align=left&amp;display=inline&amp;height=529&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=628&amp;originWidth=886&amp;size=170487&amp;status=done&amp;style=none&amp;width=746\" alt=\"image.png\" /></p>\n<h4 id=\"功能及应用场景-9\"><a class=\"anchor\" href=\"#功能及应用场景-9\">#</a> 功能及应用场景</h4>\n<p>装饰设计模式用来在运行时扩展或修改一个实例的功能。一般来说，继承可以扩展类的功能（用于类的所有实例）。但与继承不同的是，通过装饰模式，我们可以选择一个类的某个对象，并对其进行修改，而不会影响这个类中其他的实例。继承会直接为类增加功能，而装饰模式则会通过将对象与其他对象进行包装的方式将功能添加到类。</p>\n<h3 id=\"门面设计模式\"><a class=\"anchor\" href=\"#门面设计模式\">#</a> 门面设计模式</h3>\n<p>许多业务流程都会涉及复杂的业务类操作。由于流程很复杂，所以其涉及了多个业务对象，这往往会导致各个类之间的紧密耦合，从而降低系统的灵活性和设计的清晰度。底层业务组件间的复杂关系会使客户端的代码编写变得很困难。<br />\n门面模式简化了到复杂系统的外部接口。为此它会对所有的类进行整合，并构建一个复杂系统的子系统。<br />\n门面模式能够将用户与系统内部复杂的细节相互屏蔽，并只为用户提供简化后的更容易使用的外部接口。同时它也将系统内部代码与接口子系统的代码相互解耦，以便修改和升级系统代码。<br />\n相比于其他设计模式，门面模式更注重实现代码的解耦。它所强调的是代码设计中很重要的一点，即代码抽象。通过提供一个简单的接口并隐藏其后的复杂性，从而实现抽象。<br />\n在这种方式下，代码的实现完全交由门面层处理。客户端只会与一个接口交互，同时也只有和这个接口交互的权限。这样就能隐藏全部系统的复杂性。总而言之，门面模式通过提供一个简单的接口为客户端简化了与复杂系统的交互。<br />\n从另一方面看，门面模式也保证了能够在不修改客户端代码的情况下对具体实现方法进行修改。</p>\n<h4 id=\"模式中包括的类-10\"><a class=\"anchor\" href=\"#模式中包括的类-10\">#</a> 模式中包括的类</h4>\n<ul>\n<li>门面层（ Facade）：它知道子系统内各个类的具体功能，并将客户端请求转换成对系统内部对象的调用。</li>\n<li>系统内部类（ ComplicatedClass）：这些类会实现系统功能，处理门面层对象分配的各项工作任务。它们本身并不知道门面层的存在，也没有对其进行任何的引用。</li>\n</ul>\n<h4 id=\"uml图-10\"><a class=\"anchor\" href=\"#uml图-10\">#</a> UML 图</h4>\n<p><img data-src=\"_v_images/1588776769193-d3a6ae4a-83d5-4fbf-b187-339039a22f25.png#align=left&amp;display=inline&amp;height=650&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=650&amp;originWidth=996&amp;size=196580&amp;status=done&amp;style=none&amp;width=996\" alt=\"image.png\" /></p>\n<h4 id=\"功能及应用场景-10\"><a class=\"anchor\" href=\"#功能及应用场景-10\">#</a> 功能及应用场景</h4>\n<ul>\n<li>想要为一个复杂的子系统提供一个简单接口。子系统随着其自身的发展往往变得越来越复杂。它们应用的大多数的设计模式会导致类的数量更多、代码段更小。这使得该子系统可重用更好，也更容易进行自定义。而对于某些无法自定义的客户端来说，它也变得难以使用。门面层可以提供对大多数客户端来说足够好的简化的调用接口。只有极少数高度定制化的客户端需要直接调用门面层之后的底层代码。</li>\n<li>在客户端和抽象层的实现类之间存在大量的依赖关系。引入一个门面层能够将客户端的子系统与其他子系统进行解耦，从而促进子系统的独立性和可移植性。</li>\n<li>你想要为你的子系统增加层级。使用一个门面层对每个子系统级别分别定义一个入口点。如果子系统之间存在依赖关系，那么你可以通过令这些子系统之间的交互全部需要经由门面层来简化彼此的依赖关系。</li>\n</ul>\n<h3 id=\"代理设计模式\"><a class=\"anchor\" href=\"#代理设计模式\">#</a> 代理设计模式</h3>\n<p>根据目的不同，有各种不同类型的代理。例如，有保护性代理，控制对某个对象的访问权限；有虚拟代理，处理开销过大而难以创建的对象，并通过远程访问控制来访问远程对象。</p>\n<h4 id=\"模式中包括的类-11\"><a class=\"anchor\" href=\"#模式中包括的类-11\">#</a> 模式中包括的类</h4>\n<h4 id=\"uml图-11\"><a class=\"anchor\" href=\"#uml图-11\">#</a> UML 图</h4>\n<p><img data-src=\"_v_images/1588778531181-f78a0447-263d-40cf-bbfd-dfc565997dcd.png#align=left&amp;display=inline&amp;height=624&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=624&amp;originWidth=934&amp;size=174488&amp;status=done&amp;style=none&amp;width=934\" alt=\"image.png\" /></p>\n<h4 id=\"功能及应用场景-11\"><a class=\"anchor\" href=\"#功能及应用场景-11\">#</a> 功能及应用场景</h4>\n<p>代理模式主要用于当我们需要用一个简单对象来表示一个复杂对象的情形。如果创建对象的开销很大，那么可以推迟其创建，并使用一个简单对象来代理其功能直到必须立即创建的时候。这个简单对象就可以称为复杂对象的代理。</p>\n<h3 id=\"享元设计模式\"><a class=\"anchor\" href=\"#享元设计模式\">#</a> 享元设计模式</h3>\n<p>享元模式能够减少用于创建和操作大量相似的细碎对象所花费的成本。享元模式主要用在需要创建大量类似性质的对象时。大量的对象会消耗高内存，享元模式给出了一个解决方案，即通过共享对象来减少内存负载它的具体实现则是根据对象属性将对象分成两种类型：内蕴状态和外蕴状态。<br />\n共享是享元模式的关键。</p>\n<h4 id=\"模式中包括的类-12\"><a class=\"anchor\" href=\"#模式中包括的类-12\">#</a> 模式中包括的类</h4>\n<ul>\n<li>抽象享元角色（ Flyweight）声明一个为具体享元角色规定了必须实现的接口，而外蕴状态就是以参数的形式通过此方法传入。</li>\n<li>具体享元角色（ Concrete Flyweight）实现享元模式接口，并存储内蕴状态。具体享元角色必须是共享的。具体享元角色必须保持其内蕴状态不变，并且能够操纵外蕴状态。</li>\n<li>享元工厂角色（FlyweightFactory）负责创建和管理享元角色。此外，该工厂确保了享元角色的共享。工厂维护了不同的享元对象池，并负责在对象创建完成时从对象池返回对象，以及向对象池添加对象。</li>\n<li>客户端（Client）维护对所有享元对象的引用，而且需要存储和计算对应的外蕴状态。</li>\n</ul>\n<h4 id=\"uml图-12\"><a class=\"anchor\" href=\"#uml图-12\">#</a> UML 图</h4>\n<p><img data-src=\"_v_images/1588820461937-2a508c21-4203-4629-bcc1-ca0750f9fe84.png#align=left&amp;display=inline&amp;height=372&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=515&amp;originWidth=1032&amp;size=209323&amp;status=done&amp;style=none&amp;width=746\" alt=\"image.png\" /></p>\n<h4 id=\"功能及应用场景-12\"><a class=\"anchor\" href=\"#功能及应用场景-12\">#</a> 功能及应用场景</h4>\n<p>当我们选择享元模式的时候，需要考虑以下因素：</p>\n<ul>\n<li>需要创建大量的对象时。</li>\n<li>由于对象众多，内存的开销是一个制约因素。</li>\n<li>大多数对象属性可以分为内蕴状态和外蕴状态。</li>\n<li>应用程序需要使用多种对象，且创建对象后需要多次重复使用。</li>\n<li>外蕴状态最好是通过计算得到的，而不需要进行存储。</li>\n</ul>\n<h2 id=\"行为型模式\"><a class=\"anchor\" href=\"#行为型模式\">#</a> 行为型模式</h2>\n<p>行为型模式是一类主要关注对象间相互通信（交互）的设计模式。这些对象之间的相互作用既能保证对象间能够交换数据，同时对象间仍然能够保持松耦合。<br />\n紧耦合一般会发生在一组紧密关联（相互依赖）的类之间。在面向对象的设计过程中，耦合引用的数量和设计过程中类与类之间的相互依赖是成正比的。用通俗的话讲，就是当一个类变化的时候，有多少可能需要同时修改其他类呢？<br />\n松耦合是软件架构设计的关键。在行为型模式中，功能实现与调用该实现的客户端之间应该是松耦合的，以避免硬编码和依赖性。<br />\n行为型模式处理不同的对象之间的通信关系，为其提供基本的通信方式，并提供实现这种通信方式的最常用、最灵活的解决方案。<br />\n行为型模式描述的不仅是类或对象的模式，同时也包括了它们之间的通信模式。行为型模式能够用来避免硬编码和依赖性。<br />\n<strong>行为型模式又分为以下子类别：</strong></p>\n<ol>\n<li>对象行为型模式：对象行为型模式使用对象组合而非继承。描述一组对象如何合作执行部分任务，而单个对象无法执行这些任务。</li>\n<li>类行为型模式：类行为型模式使用继承而不是对象组合来描述算法和流程控制。</li>\n</ol>\n<p><strong>具体包括：</strong></p>\n<ul>\n<li>职责链模式（COR）：在一系列对象链之间传递请求的方法。</li>\n<li>命令模式：命令模式主要用于在需要向对象发出请求的情况，发出请求的对象无须了解请求的操作内容，也无须了解请求的实际接收对象。</li>\n<li>解释器模式：解释器提供了在代码中使用特定语言的一种方法。解释器模式就是一种用于在程序中解析特定语言的设计模式。</li>\n<li>迭代器模式：迭代器用于顺序访问集合（组合）对象中的元素，而无须了解其内部结构。</li>\n<li>中介者模式：定义简单的类间通信。</li>\n<li>备忘录模式：捕获和恢复对象的内部状态。</li>\n<li>观察者模式：一种通知多个类进行改变的方式。</li>\n<li>状态模式：当一个对象状态改变时改变其功能。</li>\n<li>策略模式：在类中进行算法封装。</li>\n<li>模板方法模式：将算法中的部分步骤延迟到子类中进行计算。</li>\n<li>访问者模式：在不改变类的条件下为该类定义一个新的操作。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><strong>对象行为型模式</strong></th>\n<th style=\"text-align:center\"><strong>类行为型模式</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">职责链模式</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">解释器模式</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">命令模式</td>\n<td style=\"text-align:center\">模板方法模式</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">迭代器模式</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">中介者模式</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">备忘录模式</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">观察者模式</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">状态模式</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">策略模式</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">访问者模式</td>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"职责链设计模式\"><a class=\"anchor\" href=\"#职责链设计模式\">#</a> 职责链设计模式</h3>\n<p>在职责链模式中，由发送端发送一个请求到一个对象链中，链中的对象自行处理请求。如果链中的对象决定不响应请求，它会将请求转发给链中的下一个对象。<br />\n职责链的目的是通过特定设计对请求的发送者和接收者之间进行解耦。解耦是软件设计中很重要的一个方面。通过该设计模式能够使我们彻底地将发送者和接收者之间完全解耦。发送者是用于调用操作的对象，接收者是接收请求并执行相关操作的对象。通过解耦，发送者不需要关心接收者的接口。<br />\n在职责链模式中，职责是前后传递的。对于链中的对象，决定谁来响应请求的责任由整个链中左侧的对象来承担。这就像问答测验的时候传递问题一样。当提问者向一个人提问，如果他不知道答案，他就把问题传给下一个人，以此类推。当一个人回答了问题，问题就会停止向下传递。有时，也可能到达最后一个人时，还是没有人能回答问题。<br />\n我们能举出若干个职责链模式的例子：硬币分拣机、ATM 取款机、Servlet 过滤器和 Java 的异常处理机制。<br />\n在 Java 中，我们可以在 catch 语句中列出的异常序列时就抛出一个异常，catch 列表从上到下逐条扫描。如果赶上第一个进行异常处理就可以立刻完成任务，否则责任转移到下一行，直到最后一行。</p>\n<h4 id=\"模式中包括的类-13\"><a class=\"anchor\" href=\"#模式中包括的类-13\">#</a> 模式中包括的类</h4>\n<ul>\n<li>抽象处理者（Handler）：定义用于处理请求的接口。</li>\n<li>具体处理者（ Concrete Handler）：它负责处理请求。如果它能够处理这样的要求就会自行处理，否则会将请求发送到下一个处理者。</li>\n<li>客户端（Client）：将命令发送到职责链中第一个能够处理该请求的对象。</li>\n</ul>\n<h4 id=\"uml图-13\"><a class=\"anchor\" href=\"#uml图-13\">#</a> UML 图</h4>\n<p><img data-src=\"_v_images/1588839044031-1dcdb9c4-a7c0-43b0-af86-4fb919336801.png#align=left&amp;display=inline&amp;height=483&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=483&amp;originWidth=942&amp;size=137762&amp;status=done&amp;style=none&amp;width=942\" alt=\"image.png\" /></p>\n<h4 id=\"功能及应用场景-13\"><a class=\"anchor\" href=\"#功能及应用场景-13\">#</a> 功能及应用场景</h4>\n<ul>\n<li>发送者并不知道在链中的哪个对象会响应请求。</li>\n<li>职责链中的每一个对象都有责任决定是否对请求进行响应，如果这些对象有能力响应请求就会响应请求。</li>\n<li>如果对象（或节点）决定向后传递请求它需要具有选择下一个节点和继续传递的能力。</li>\n<li>也有可能没有任何一个节点能够响应请求（有些请求可能无法得到处理）</li>\n<li>会在运行时确定哪些对象能够响应请求。</li>\n</ul>\n<h3 id=\"命令设计模式\"><a class=\"anchor\" href=\"#命令设计模式\">#</a> 命令设计模式</h3>\n<p>命令模式（也称为行动模式、业务模式）是一个对象行为型模式。<br />\n这使我们能够实现发送者和接收者之间完全解耦。发送者是调用操作的对象，接收者是接收请求并执行特定操作的对象。通过解耦，发送者无须了解接收者的接口。在这里，请求的含义是需要被执行的命令。</p>\n<h4 id=\"模式中包括的类-14\"><a class=\"anchor\" href=\"#模式中包括的类-14\">#</a> 模式中包括的类</h4>\n<ul>\n<li>抽象命令类（Command）：在类中对需要执行的命令接口进行声明。</li>\n<li>具体命令类（ ConcreteCommand）：将接收者对象和行为之间进行绑定。它通过调用接收者中相应的操作实现 execute 方法。</li>\n<li>客户端（ Client）：客户端完成对命令对象的实例化并提供随后需要调用的方法的信息。</li>\n<li>调用者（Invoker）：调用者决定合适的调用方法。</li>\n<li>接收者（Receiver）：接收者是包含方法代码的类的一个实例。这意味着它知道如何处理一个请求并执行相应的操作。任何一个类都可以作为接收者。</li>\n</ul>\n<h4 id=\"uml图-14\"><a class=\"anchor\" href=\"#uml图-14\">#</a> UML 图</h4>\n<p><strong><img data-src=\"_v_images/1588841461626-35402966-4817-4f7c-bc64-7fa4dbfc6a84.png#align=left&amp;display=inline&amp;height=344&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=433&amp;originWidth=938&amp;size=126130&amp;status=done&amp;style=none&amp;width=746\" alt=\"image.png\" /></strong></p>\n<h4 id=\"功能及应用场景-14\"><a class=\"anchor\" href=\"#功能及应用场景-14\">#</a> 功能及应用场景</h4>\n<ul>\n<li>通过参数化对象实现功能执行。命令是面向对象式的，而不是回调函数式的。</li>\n<li>指定消息队列并在不同的时间执行请求一个命令对象可以有独立于原始请求的生命周期。如果一个请求的接收者可以由一个独立地址空间的方式来表示，那么你可以将请求对应的命令对象转换到不同的进程并在其中完成请求。</li>\n<li>支持撤销。命令的执行操作可以作为状态进行存储，并在需要时实现命令撤销。命令接口必须增加一个 unexecute 操作，支持撤销之前命令调用的执行效果。执行的命令存储在命令的历史列表中。无限次数的撤销和重做是通过遍历这个列表并分别调用 unexecute 和 execute 来实现的。</li>\n<li>支持日志记录变化，在系统崩溃的情况下使命令可以重新应用。通过增加 load 和 store 操作命令接口参数，你可以保存一个持续变化的日志。从系统崩溃中恢复需要从磁盘重新加载日志命令和使用 Execute 作重新执行这些命令。</li>\n<li>通过在原生操作基础上的高层操作构建系统。这样的结构在支持交易操作的信息系统中很常见。一个交易事务封装一组变化的数据。命令模式提供了一种交易模型。命令都有一个共同的接口，允许你使用相同的方式调用所有的交易。这种模式也使得它很容易与新的交易系统进行交互扩展。</li>\n</ul>\n<p><strong>注意事项：</strong></p>\n<ul>\n<li>\n<p>目的：将请求封装为一个对象，从而使客户端可以将不同的请求、队列、日志请求及其他支持撤销的操作进行参数化。</p>\n</li>\n<li>\n<p>发出请求的对象无须知道请求对应的操作或请求接收者的任何信息。</p>\n</li>\n<li>\n<p>后果：</p>\n<ul>\n<li>将调用操作的对象和执行操作的对象之间对命令进行解耦。即调用者和接收者之间解耦。</li>\n<li>命令转换为一类对象。使其可以像其他对象那样进行操作和扩展。</li>\n<li>我们可以将命令组合成一个组合命令。一般来说，组合命令是一个组合模式的实例。</li>\n<li>很容易添加新的命令，因为我们无须改变现有的类。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"解释器设计模式\"><a class=\"anchor\" href=\"#解释器设计模式\">#</a> 解释器设计模式</h3>\n<p>解释器模式是一种用于在程序中解析特定语法的设计模式。解释器模式是组合模式的一种应用。<br />\n对于特定的某种语言，解释器模式能够定义针对其语法表示形式的解释器，并实现对该语言语句的翻译和解释。</p>\n<h4 id=\"模式中包括的类-15\"><a class=\"anchor\" href=\"#模式中包括的类-15\">#</a> 模式中包括的类</h4>\n<ul>\n<li>内容类（Context）：包含解释器的全局信息</li>\n<li>表达式（AbstractExpression）：带有名叫 interpret 抽象方法的抽象类。它会声明执行操作的接口。</li>\n<li>终结符表达式（TerminalExpression）：就是带有终结符的表达式。</li>\n<li>非终结符表达式（ NonterminalExpression）：在两个终结符表达式或非终结符表达式之间实现逻辑运算（与或运算）的表达式。</li>\n<li>客户端（Client）：建立抽象树，并调用抽象树中的 interpret 方法。</li>\n</ul>\n<h4 id=\"uml图-15\"><a class=\"anchor\" href=\"#uml图-15\">#</a> UML 图</h4>\n<p><img data-src=\"_v_images/1588846767979-ce72003e-375a-4eea-8d13-eed6b726aa3b.png#align=left&amp;display=inline&amp;height=649&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=649&amp;originWidth=992&amp;size=178099&amp;status=done&amp;style=none&amp;width=992\" alt=\"image.png\" /></p>\n<h4 id=\"功能及应用场景-15\"><a class=\"anchor\" href=\"#功能及应用场景-15\">#</a> 功能及应用场景</h4>\n<p>解释器模式的适用范围非常有限。我们可以说解释器模式仅仅用于需要进行正式语法解释的地方，但这些领域往往已经有了更好的标准的解决方法，因此，在实际使用中，并不会经常使用该模式。该模式可以用于解释使用了特定语法的表达式或者建立某个简单的规则引擎的时候。</p>\n<h3 id=\"迭代器设计模式\"><a class=\"anchor\" href=\"#迭代器设计模式\">#</a> 迭代器设计模式</h3>\n<p>迭代器模式也是一种行为型模式。迭代器模式允许对一组对象元素的遍历（也叫收集）以完成功能实现。</p>\n<h4 id=\"模式中包括的类-16\"><a class=\"anchor\" href=\"#模式中包括的类-16\">#</a> 模式中包括的类</h4>\n<ul>\n<li>迭代器（Iterator）：它会实现一个用于定义迭代器的抽象迭代器接口。</li>\n<li>具体迭代器（Concretel）：这是迭代器的实现（实现迭代器接口）。</li>\n<li>抽象容器（Container）：这是用于定义聚合关系的接口。</li>\n<li>具体容器（ConcreteContainer）：一个聚合关系的实现。</li>\n</ul>\n<h4 id=\"uml图-16\"><a class=\"anchor\" href=\"#uml图-16\">#</a> UML 图</h4>\n<p><img data-src=\"_v_images/1588848682603-c5da8658-bbda-4c63-9c3f-f9bc80a93299.png#align=left&amp;display=inline&amp;height=462&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=462&amp;originWidth=816&amp;size=135540&amp;status=done&amp;style=none&amp;width=816\" alt=\"image.png\" /></p>\n<h4 id=\"功能及应用场景-16\"><a class=\"anchor\" href=\"#功能及应用场景-16\">#</a> 功能及应用场景</h4>\n<ul>\n<li>需要访问一个聚合（也称为容器）对象的内容，而无须了解其内部表示。-</li>\n<li>支持对聚合对象的多种遍历方式。</li>\n<li>为遍历不同的聚合结构提供统一的接口（即支持多态迭代）。</li>\n<li>迭代器模式允许我们访问集合对象中的内容，而无须暴露其内部数据结构。</li>\n<li>支持多个迭代器同时遍历集合对象。这意味着我们可以对相同的集合创建多个独立的迭代器。</li>\n<li>为遍历不同的集合提供统一的接口。</li>\n</ul>\n<h3 id=\"中介者设计模式\"><a class=\"anchor\" href=\"#中介者设计模式\">#</a> 中介者设计模式</h3>\n<p>中介者模式主要是关于数据交互的设计模式。中介者设计模式很容易理解，却难以实现。该模式的核心是一个中介者对象，负责协调一系列对象之间一系列不同的数据请求。这一系列对象称为同事类。<br />\n同事类会让中介者知道它们会发生变化这样中介者负责处理变化对不同对象之间交互的影响。</p>\n<h4 id=\"模式中包括的类-17\"><a class=\"anchor\" href=\"#模式中包括的类-17\">#</a> 模式中包括的类</h4>\n<ul>\n<li>中介者接口（Mediator）：它定义了一个接口来实现同事类对象之间的沟通。</li>\n<li>具体中介者（ ConcreteMediator）：它知道各个同事类，并和这些同事类保持相互引用。它实现了与同事类之间的通信和消息传递。</li>\n<li>同事类（ Colleague）：这些类保存了对中介者的引用。无论它们想和任何其他同事类进行交互，都必须通过与中介类通信来实现。</li>\n</ul>\n<h4 id=\"uml图-17\"><a class=\"anchor\" href=\"#uml图-17\">#</a> UML 图</h4>\n<p><img data-src=\"_v_images/1588850989407-80696883-cc5d-472b-a4de-0d5f5edd4cc4.png#align=left&amp;display=inline&amp;height=437&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=437&amp;originWidth=979&amp;size=149617&amp;status=done&amp;style=none&amp;width=979\" alt=\"image.png\" /></p>\n<h4 id=\"功能及应用场景-17\"><a class=\"anchor\" href=\"#功能及应用场景-17\">#</a> 功能及应用场景</h4>\n<ul>\n<li>一组对象使用了标准的通信方式，但整体通信的连接都非常复杂。由此产生的相互依赖的结果导致系统难以结构化，也很难理解。</li>\n<li>由于对象之间的通信和相互引用，导致对象难以重用。</li>\n<li>分布在多个类中的行为能够被统一定制化，而无须创建过多的子类。</li>\n</ul>\n<p><strong>需要注意的问题：</strong><br />\n实际使用中介者模式的时候，反而会让问题变得越来越复杂。所以最佳的实践是仅让中介者类负责对象之间的通信部分。</p>\n<ul>\n<li>定义一个对象来负责一系列对象之间的交互。</li>\n<li>同事类发送和接收请求都需要通过中介者。</li>\n</ul>\n<p><strong>功能：</strong></p>\n<ul>\n<li>它对同事类进行解耦。中介类实现了同事类之间的松耦合。你可以相互独立地对不同的同事类进行修改和重用。</li>\n<li>它简化了对象协议。中介者取代了许多交互作用，而实现了与多个同事类之间一对多的通信方式。一对多关系更容易理解、维护和扩展。</li>\n<li>它集中了控制。中介者模式在中介者中集成了系统交互的复杂性。因此通过中介封装协议之后，它会比任何单一的同事类都更为复杂。这会使中介者作为一个整体也很难维护。</li>\n<li>门面模式不同于中介者模式的是，它抽象了对象的子系统以提供一个更方便的接口。该种抽象是单向的。也就是说，门面对象会向子系统中的各个类发出请求，反之则不会。相比之下，中介者模式更像是同事类对象之间通过中介者的合作行为，系统的交互都是多向的。</li>\n<li>当各个同事类只和一个中介者对象交互时，没有必要再去定义一个抽象的中介者类。抽象中介者只用于多个同事类通过多个抽象中介者的子类进行交互的情况，反之则不同。</li>\n</ul>\n<h3 id=\"备忘录设计模式\"><a class=\"anchor\" href=\"#备忘录设计模式\">#</a> 备忘录设计模式</h3>\n<p>我们每天至少会使用一次这种模式。备忘录模式提供了一种使对象恢复到其以前状态的能力（通过回滚撤销）。备忘录模式是通过两个对象实现的：发起者和管理者。发起者是具有内部状态的某个对象。管理者则会对发起者执行一些操作，并实现撤销更改。</p>\n<h4 id=\"模式中包括的类-18\"><a class=\"anchor\" href=\"#模式中包括的类-18\">#</a> 模式中包括的类</h4>\n<ul>\n<li>发起者（Originator）：发起者知道如何保存自己。这是我们想要保存状态的类。</li>\n<li>管理者（ Caretaker）：管理者是用于管理发起者进行状态保存的对象，具体处理发起者何时、如何、为何对状态进行存储。管理员应能够对发起者进行修改，同时也能够撤销这些修改。</li>\n<li>备忘录（Memento）：备忘录会保存发起人的状态信息，而这些状态不能由管理者修改。</li>\n</ul>\n<h4 id=\"uml图-18\"><a class=\"anchor\" href=\"#uml图-18\">#</a> UML 图</h4>\n<p><img data-src=\"_v_images/1588858153516-9c6b4ce0-aa41-42c4-b4c5-ae14e7faae51.png#align=left&amp;display=inline&amp;height=360&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=360&amp;originWidth=994&amp;size=145133&amp;status=done&amp;style=none&amp;width=994\" alt=\"image.png\" /></p>\n<h4 id=\"功能及应用场景-18\"><a class=\"anchor\" href=\"#功能及应用场景-18\">#</a> 功能及应用场景</h4>\n<p>当我们在实际应用中需要提供撤销机制，当一个对象有可能需要在后续操作中恢复其内部状态时，就需要使用备忘录模式。结合本设计模式实现对象状态序列化，能够使其易于保存对象的状态并进行状态回滚。<br />\n当一个对象状态的快照必须被存储，且在后续操作过程中需要被恢复时，就可以使用备忘录模式。</p>\n<h3 id=\"观察者设计模式\"><a class=\"anchor\" href=\"#观察者设计模式\">#</a> 观察者设计模式</h3>\n<p>在观察者模式中，一种叫作被观察者的对象维护了观察者对象的集合。当被观察者对象变化时，它会通知观察者。<br />\n在被观察者对象所维护的观察者集合中能够添加或删除观察者。被观察者的状态变化能够传递给观察者。这样观察者能够根据被观察者的状态变化做出相应的改变。</p>\n<h4 id=\"模式中包括的类-19\"><a class=\"anchor\" href=\"#模式中包括的类-19\">#</a> 模式中包括的类</h4>\n<ul>\n<li>被观察者（Listener）：定义了向客户端添加和移除观察者操作的接口或抽象类。</li>\n<li>具体被观察者（ ConcreteListener）：具体被观察者类。它维护了对象的状态，并在当其状态改变时通知各个观察者。</li>\n<li>观察者（Observer）：定义了用于通知对象的接口或抽象类。</li>\n<li>具体观察者（ ConcreteObserver）：具体实现了观察者。</li>\n</ul>\n<h4 id=\"uml图-19\"><a class=\"anchor\" href=\"#uml图-19\">#</a> UML 图</h4>\n<p><img data-src=\"_v_images/1588859146567-662ae183-11ae-475d-8d8d-a8549f3d4026.png#align=left&amp;display=inline&amp;height=431&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=431&amp;originWidth=978&amp;size=180698&amp;status=done&amp;style=none&amp;width=978\" alt=\"image.png\" /></p>\n<h4 id=\"功能及应用场景-19\"><a class=\"anchor\" href=\"#功能及应用场景-19\">#</a> 功能及应用场景</h4>\n<ul>\n<li>当一个对象的改变需要其他对象同时改变，而我们并不知道需要有多少个对象一起改变时。</li>\n<li>当一个对象必须通知其他对象，而无须了解这些对象是谁时。</li>\n<li>当一个抽象包含有两个方面，其中一个依赖于另一个。将这些方面封装成独立的对象，以便我们独立改变和重复使用它们时。</li>\n</ul>\n<h3 id=\"状态设计模式\"><a class=\"anchor\" href=\"#状态设计模式\">#</a> 状态设计模式</h3>\n<p>状态模式是一种行为型模式。状态模式背后的理念是根据其状态变化来改变对象的行为。状态模式允许对象根据内部状态（内容类）实现不同的行为。内容类可以具有大量的内部状态，每当对内容类调用 request 方法时，消息就被委托给状态类进行处理。<br />\n状态类接口定义了一个对所有具体状态类都有效的通用接口，并在其中封装了与特定状态相关的所有操作。具体状态类对请求提供各自具体的实现。当内容类的状态变化时，那么与之关联的具体状态类也会发生一定相应的改变。</p>\n<h4 id=\"模式中包括的类-20\"><a class=\"anchor\" href=\"#模式中包括的类-20\">#</a> 模式中包括的类</h4>\n<ul>\n<li>内容类（ Context）：内容类主要用于状态模式的客户端。客户端并不直接访问对象的状态。内容类拥有一个具体的状态对象并根据其当前状态提供所需实现的行为。</li>\n<li>抽象状态类（ State）：这个抽象类是所有具体状态类的基类。状态类定义了一个通用接口。内容类对象能够通过使用该接口实现对不同功能的改变。在状态类及其子类的各个条目或属性中，本身并没有任何的状态。</li>\n<li>具体状态类（ ConcreteState）：具体状态类根据内容类所提供的状态实现真正的功能改变。每个状态类所提供的行为都适用于内容类对象的某一个状态。它们也包含着由内容类状态变化所下发的指令。</li>\n</ul>\n<h4 id=\"uml图-20\"><a class=\"anchor\" href=\"#uml图-20\">#</a> UML 图</h4>\n<p><img data-src=\"_v_images/1588860191434-2b5ff1d1-06e8-4036-8f95-0adfe7e383c1.png#align=left&amp;display=inline&amp;height=397&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=397&amp;originWidth=1013&amp;size=178430&amp;status=done&amp;style=none&amp;width=1013\" alt=\"image.png\" /></p>\n<h4 id=\"功能及应用场景-20\"><a class=\"anchor\" href=\"#功能及应用场景-20\">#</a> 功能及应用场景</h4>\n<ul>\n<li>状态模式为对象提供了一个清晰的状态表示。</li>\n<li>它允许一个对象在运行时部分清晰明了地改变其类型。</li>\n</ul>\n<h3 id=\"策略设计模式\"><a class=\"anchor\" href=\"#策略设计模式\">#</a> 策略设计模式</h3>\n<p>策略模式主要用于需要使用不同的算法来处理不同的数据（对象）时。这意味着策略模式定义了一系列算法，并且使其可以替换使用。策略模式是一种可以在运行时选择算法的设计模式。<br />\n本模式可以使算法独立于调用算法的客户端。策略模式也称为政策模式。在使用多种不同的算法（每种算法都可以对应一个单独的类，而每个类的功能又各不相同）时可以运用策略模式。</p>\n<h4 id=\"模式中包括的类-21\"><a class=\"anchor\" href=\"#模式中包括的类-21\">#</a> 模式中包括的类</h4>\n<ul>\n<li>抽象策略类（Strategy）：定义一个所有算法都支持的通用接口。内容类会使用这个接口来调用由具体策略类定义的各个算法。</li>\n<li>具体策略类（ ContreteStrategy）：每个具体策略类都会实现一个相应的算法。</li>\n<li>内容类（ Context）：包含一个对策略对象的引用。它可以定义一个用于策略类访问内容类数据的接口。内容类对象包含了对将要使用的具体策略对象的引用。当需要进行特定操作时，会从对应的策略类对象中运行相应的算法。内容类本身觉察不到策略类的执行。如果有必要的话，还可以定义专用的对象来传递从内容类对象到策略类的数据。内容类对象接收来自客户端的请求，并将其委托给策略类对象。通常具体策略类是由客户端创建，并传递给内容类。从这一点来讲，客户端仅与内容类进行交互。</li>\n</ul>\n<h4 id=\"uml图-21\"><a class=\"anchor\" href=\"#uml图-21\">#</a> UML 图</h4>\n<p><img data-src=\"_v_images/1588861529453-aa147daa-653f-4559-b2ee-fdb0a370bf11.png#align=left&amp;display=inline&amp;height=426&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=426&amp;originWidth=1095&amp;size=182081&amp;status=done&amp;style=none&amp;width=1095\" alt=\"image.png\" /></p>\n<h4 id=\"功能及应用场景-21\"><a class=\"anchor\" href=\"#功能及应用场景-21\">#</a> 功能及应用场景</h4>\n<p>当我们有多种不同的算法可供选择（每种算法都可以对应一个单独的类，而每个类的功能又各不相同）时，可以应用策略模式。策略模式会定义一组算法并能够使其相互替代使用。</p>\n<h3 id=\"模板方法设计模式\"><a class=\"anchor\" href=\"#模板方法设计模式\">#</a> 模板方法设计模式</h3>\n<p>模板方法会定义算法的各个执行步骤。算法的一个或多个步骤可以由子类通过重写来实现，同时保证算法的完整性并能够实现多种不同的功能。<br />\n类行为型模式使用继承来实现模式的功能。在模板方法模式中，会有一个方法（ Template method 方法）来定义算法的各个步骤。这些步骤（即方法）的具体实现会放到子类中。也就是说，在模板方法中定义了特定算法，但该算法的具体步骤仍然需要通过子类来定义。模板方法会由一个抽象类来实现在这个抽象类中还会声明该算法的各个步骤（方法），最后将其具体实现的方法声明实现为抽象类的子类。</p>\n<h4 id=\"模式中包括的类-22\"><a class=\"anchor\" href=\"#模式中包括的类-22\">#</a> 模式中包括的类</h4>\n<ul>\n<li>抽象类（ AbstractClass）：定义了算法的抽象操作，并交由具体的子类完成这些操作的具体实现。它实现了一个模板方法，它该方法包含了算法的各个步骤。该模板方法还会在抽象类中定义各个相应步骤的基本操作。</li>\n<li>具体类（ ConcreteClass）：他们通过执行基本操作来实现算法类的具体步骤。当调用一个具体类时，模板方法代码会从基类执行，而模板方法所使用的各个方法由派生类实现和调用。</li>\n</ul>\n<h4 id=\"uml图-22\"><a class=\"anchor\" href=\"#uml图-22\">#</a> UML 图</h4>\n<p><img data-src=\"_v_images/1588862264475-f62b4542-a18a-410e-b841-96049a3f2b44.png#align=left&amp;display=inline&amp;height=427&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=561&amp;originWidth=980&amp;size=162268&amp;status=done&amp;style=none&amp;width=746\" alt=\"image.png\" /></p>\n<h4 id=\"功能及应用场景-22\"><a class=\"anchor\" href=\"#功能及应用场景-22\">#</a> 功能及应用场景</h4>\n<p><strong>应用场景：</strong></p>\n<ul>\n<li>当一个算法的功能需要能够改变，并通过在子类中对功能重写来实现这种改变。</li>\n<li>当我们要避免代码重复时，能够在子类中实现算法不同的变化。</li>\n<li>在一开始，模板方法可能不是一个显而易见的选择。最明显的现象会是当我们发现几乎完全一样的类在执行某些类似的逻辑。这时，我们就应该考虑使用模板方法模式来清理现有代码。</li>\n</ul>\n<h3 id=\"访问者设计模式\"><a class=\"anchor\" href=\"#访问者设计模式\">#</a> 访问者设计模式</h3>\n<p>访问者模式用来简化对象相关操作的分组。这些操作是由访问者来执行的，而不是把这些代码放在被访问的类中。由于访问的操作是由访问者执行的，而不是由被访问的类，这样执行操作的代码会集中在访问者中，而不是分散在对象分组中。这为代码提供了更好的可维护性。访问者模式也避免了使用 instanceof 运算符对相似的类执行计算。</p>\n<h4 id=\"模式中包括的类-23\"><a class=\"anchor\" href=\"#模式中包括的类-23\">#</a> 模式中包括的类</h4>\n<ul>\n<li>访问者（ Visitor）：包括一个接口或抽象类，用于声明在所有类型的可访问对象中访问哪些操作。通常操作的名称是相同的，而是由该方法的参数来区分不同的操作。由输入对象类型来决定访问该方法中的哪一个。</li>\n<li>具体访问者（ Concrete Visitor）：用于实现各个类型的访问者和各个类型的访问方法。它在抽象访问者中进行声明，并各自独立实现。每一个具体访问者会负责实现不同的功能。当定义一个新的访问者时，只需要将其传递给对象结构即可。</li>\n<li>元素类（Element）：一个抽象对象用于声明所接受的操作。它是一个入口点，能够允许哪一类访问者对象访问。在集合中的每个对象都需要实现该抽象对象，以便相应访问者能够实现对其进行访问。</li>\n<li>具体元素类（ Concrete Element）：这些类实现了抽象元素类的接口或类，并定义了所接受的操作。通过其可接受的操作，能够将访问者对象传递给该对象。</li>\n<li>结构对象（ ObjectStruture）：这是一个包含了所有可访问对象的类。它提供了一种机制来遍历所有元素。这种结构不一定是一个集合，也可以是一个极其复杂的结构，如组合对象。</li>\n</ul>\n<h4 id=\"uml图-23\"><a class=\"anchor\" href=\"#uml图-23\">#</a> UML 图</h4>\n<p><img data-src=\"_v_images/1588863690354-5649da92-3741-4812-9f63-b5b7d0960238.png#align=left&amp;display=inline&amp;height=835&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=835&amp;originWidth=1141&amp;size=373163&amp;status=done&amp;style=none&amp;width=1141\" alt=\"image.png\" /></p>\n<h4 id=\"功能及应用场景-23\"><a class=\"anchor\" href=\"#功能及应用场景-23\">#</a> 功能及应用场景</h4>\n<p>在 visitCollection () 方法中，我们调用 Visitable.accept (this) 来实现对正确的访问者方法进行调用。这叫作双重分派。访问者调用元素类中的方法，又会回到对访问者类中进行调用。<br />\n<strong>模式问题：</strong><br />\n在使用访问者模式的情况下，要想添加新的具体元素（数据结构）会更加困难。添加一个 ConcreteElement 会涉及向访问者接口添加新的操作和在每一个具体访问者实现中添加对应的实现。<strong>访问者模式更适用于对象结构非常稳定，而对象的操作却需要经常变化的情况下。</strong><br />\n访问者模式只提供处理每种数据类型的方法，并且让数据对象确定调用哪个方法。由于数据对象本质上都知道其自身的类型，所以在访问者模式中算法决定所调用的方法所起到的作用是微不足道的。<br />\n因此，数据的整体处理包括对数据对象的分发以及通过对适当的访问者处理方法的二次分发。这就叫作双重分派。<br />\n使用访问者模式的一个主要优点是，对于在我们的数据结构中添加需要执行的新的操作来说，是非常容易的。我们所要做的就是创建一个新的访问者，并定义相应的操作。<br />\n访问者模式的主要问题是，因为每个访问者需要有相应的方法来处理每一种可能的具体数据，那么一旦实现了访问者模式，其具体类的数量和类型就不能被轻易改变。</p>\n",
            "tags": [
                "学习",
                "设计模式"
            ]
        },
        {
            "id": "http://example.com/2022/05/30/Database/",
            "url": "http://example.com/2022/05/30/Database/",
            "title": "数据库",
            "date_published": "2022-05-30T03:00:00.000Z",
            "content_html": "<h1 id=\"数据库\"><a class=\"anchor\" href=\"#数据库\">#</a> 数据库</h1>\n<ul>\n<li>数据库基础\n<ul>\n<li><a href=\"#%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%89%B9%E6%80%A7\">事务的概念和特性？</a></li>\n<li><a href=\"#%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%93%AA%E4%BA%9B%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98\">会出现哪些并发一致性问题？</a></li>\n<li><a href=\"#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB\">数据库的四种隔离级别？</a></li>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81\">什么是乐观锁和悲观锁？</a></li>\n<li><a href=\"#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B0%81%E9%94%81%E7%B1%BB%E5%9E%8B\">常见的封锁类型？</a></li>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE\">什么是三级封锁协议？</a></li>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%A4%E6%AE%B5%E9%94%81%E5%8D%8F%E8%AE%AE\">什么是两段锁协议？</a></li>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-mvcc\">什么是 MVCC？</a></li>\n<li><a href=\"#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%8C%83%E5%BC%8F\">数据库的范式？</a></li>\n<li><a href=\"#%E5%88%97%E4%B8%BE%E5%87%A0%E7%A7%8D%E8%A1%A8%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F\">列举几种表连接方式？</a></li>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%BC%BA%E7%82%B9\">什么是存储过程？有哪些优缺点？</a></li>\n<li><a href=\"#DropDeleteTruncate%E7%9A%84%E5%8C%BA%E5%88%AB\">Drop/Delete/Truncate 的区别？</a></li>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%86%E5%9B%BE%E4%BB%80%E4%B9%88%E6%98%AF%E6%B8%B8%E6%A0%87\">什么是视图？什么是游标？</a></li>\n</ul>\n</li>\n<li>MySQL\n<ul>\n<li><a href=\"#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86b%E6%A0%91\">数据库索引的实现原理（B + 树）</a></li>\n<li><a href=\"#%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9\">使用索引的优点</a></li>\n<li><a href=\"#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%E7%B4%A2%E5%BC%95%E4%BC%9A%E5%A4%B1%E6%95%88\">哪些情况下索引会失效？</a></li>\n<li><a href=\"#%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95\">在哪些地方适合创建索引？</a></li>\n<li><a href=\"#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB\">索引的分类？</a></li>\n<li><a href=\"#MySQL%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-InnoDB-%E5%92%8C-MyISAM-%E7%9A%84%E5%8C%BA%E5%88%AB\">MySQL 的两种存储引擎 InnoDB 和 MyISAM 的区别？</a></li>\n<li><a href=\"#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93\">如何优化数据库？</a></li>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88\">什么是主从复制？实现原理是什么？</a></li>\n</ul>\n</li>\n<li>NoSQL/Redis\n<ul>\n<li><a href=\"%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB\">关系型数据库和非关系型数据库的区别？</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%8F%82%E8%80%83\">参考</a></li>\n</ul>\n<hr />\n<h3 id=\"事务的概念和特性\"><a class=\"anchor\" href=\"#事务的概念和特性\">#</a> 事务的概念和特性？</h3>\n<p>概念：事务（Transaction）是一个操作序列，不可分割的工作单位，以 BEGIN TRANSACTION 开始，以 ROLLBACK/COMMIT 结束</p>\n<p>特性（ACID）：</p>\n<ul>\n<li><strong>原子性</strong>（Atomicity）：逻辑上是不可分割的操作单元，事务的所有操作要么全部提交成功，要么全部失败回滚（用回滚日志实现，反向执行日志中的操作）；</li>\n<li><strong>一致性</strong>（Consistency）：事务的执行必须使数据库保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的；</li>\n<li><strong>隔离性</strong>（Isolation）：一个事务所做的修改在最终提交以前，对其它事务是不可见的（并发执行的事务之间不能相互影响）；</li>\n<li><strong>持久性</strong>（Durability）：一旦事务提交成功，对数据的修改是永久性的</li>\n</ul>\n<h3 id=\"会出现哪些并发一致性问题\"><a class=\"anchor\" href=\"#会出现哪些并发一致性问题\">#</a> 会出现哪些并发一致性问题？</h3>\n<ul>\n<li><strong>丢失修改</strong>：一个事务对数据进行了修改，在事务提交之前，另一个事务对同一个数据进行了修改，覆盖了之前的修改；</li>\n<li><strong>脏读</strong>（Dirty Read）：一个事务读取了被另一个事务修改、但未提交（进行了回滚）的数据，造成两个事务得到的数据不一致；</li>\n<li><strong>不可重复读</strong>（Nonrepeatable Read）：在同一个事务中，某查询操作在一个时间读取某一行数据和之后一个时间读取该行数据，发现数据已经发生修改（针对<strong> update</strong> 操作）；</li>\n<li><strong>幻读</strong>（Phantom Read）：当同一查询多次执行时，由于其它事务在这个数据范围内执行了插入操作，会导致每次返回不同的结果集（和不可重复读的区别：针对的是一个数据整体 / 范围；并且针对<strong> insert</strong> 操作）</li>\n</ul>\n<h3 id=\"数据库的四种隔离级别\"><a class=\"anchor\" href=\"#数据库的四种隔离级别\">#</a> 数据库的四种隔离级别？</h3>\n<ul>\n<li><strong>未提交读</strong>（Read Uncommited）：在一个事务提交之前，它的执行结果对其它事务也是可见的。会导致脏读、不可重复读、幻读；</li>\n<li><strong>提交读</strong>（Read Commited）：一个事务只能看见已经提交的事务所作的改变。可避免脏读问题；</li>\n<li><strong>可重复读</strong>（Repeatable Read）：可以确保同一个事务在多次读取同样的数据时得到相同的结果。（MySQL 的默认隔离级别）。可避免不可重复读；</li>\n<li><strong>可串行化</strong>（Serializable）：强制事务串行执行，使之不可能相互冲突，从而解决幻读问题。可能导致大量的超时现象和锁竞争，实际很少使用。</li>\n</ul>\n<h3 id=\"什么是乐观锁和悲观锁\"><a class=\"anchor\" href=\"#什么是乐观锁和悲观锁\">#</a> 什么是乐观锁和悲观锁？</h3>\n<ul>\n<li>悲观锁：认为数据随时会被修改，因此每次读取数据之前都会上锁，防止其它事务读取或修改数据；应用于<strong>数据更新比较频繁</strong>的场景；</li>\n<li>乐观锁：操作数据时不会上锁，但是更新时会判断在此期间有没有别的事务更新这个数据，若被更新过，则失败重试；适用于<strong>读多写少</strong>的场景。乐观锁的实现方式有：\n<ul>\n<li>加一个版本号或者时间戳字段，每次数据更新时同时更新这个字段；</li>\n<li>先读取想要更新的字段或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"常见的封锁类型\"><a class=\"anchor\" href=\"#常见的封锁类型\">#</a> 常见的封锁类型？</h3>\n<p>意向锁是 InnoDB 自动加的， 不需用户干预。<br />\n对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB<br />\n 会自动给涉及数据集加排他锁（X)；<br />\n对于普通 SELECT 语句，InnoDB 不会加任何锁；<br />\n事务可以通过以下语句显式给记录集加共享锁或排他锁：<br />\n共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。<br />\n排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁</p>\n<ul>\n<li><strong>排它锁</strong>（Exclusive Lock）/ X 锁：事务对数据加上 X 锁时，只允许此事务读取和修改此数据，并且其它事务不能对该数据加任何锁；</li>\n<li><strong>共享锁</strong>（Shared Lock）/ S 锁：加了 S 锁后，该事务只能对数据进行读取而不能修改，并且其它事务只能加 S 锁，不能加 X 锁</li>\n<li><strong>意向锁</strong>（Intention Locks）：\n<ul>\n<li>一个事务在获得某个<strong>数据行</strong>对象的 S 锁之前，必须先获得<strong>整个表</strong>的 IS 锁或更强的锁；</li>\n<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得整个表的 IX 锁；</li>\n<li>IS/IX 锁之间都是兼容的；</li>\n<li>好处：如果一个事务想要对整个表加 X 锁，就需要先检测是否有其它事务对该表或者该表中的某一行加了锁，这种检测非常耗时。有了意向锁之后，只需要检测整个表是否存在 IX/IS/X/S 锁就行了</li>\n</ul>\n</li>\n</ul>\n<p>锁的作用：用于管理对共享资源的并发访问，保证数据库的完整性和一致性<br />\n &lt;details&gt;<br />\n&lt;summary&gt; 封锁粒度的概念 &lt;/summary&gt;</p>\n<p>MySQL 中提供了两种封锁粒度：<strong>行级锁</strong>以及<strong>表级锁</strong>。</p>\n<p>封锁粒度小：</p>\n<ul>\n<li>好处：锁定的数据量越少，发生锁争用的可能就越小，系统的<strong>并发程度</strong>就越高；</li>\n<li>坏处：<strong>系统开销</strong>大（加锁、释放锁、检查锁的状态都需要消耗资源）<br />\n&lt;/details&gt;</li>\n</ul>\n<p>&lt;details&gt;<br />\n&lt;summary&gt;MySQL 加锁 &lt;/summary&gt;</p>\n<pre><code>SELECT ... LOCK In SHARE MODE;\nSELECT ... FOR UPDATE;\n</code></pre>\n<p>&lt;/details&gt;</p>\n<h3 id=\"什么是三级封锁协议\"><a class=\"anchor\" href=\"#什么是三级封锁协议\">#</a> 什么是三级封锁协议？</h3>\n<ul>\n<li>一级封锁协议：事务在修改数据之前必须先对其加 X 锁，直到事务结束才释放。可以解决丢失修改问题（两个事务不能同时对一个数据加 X 锁，避免了修改被覆盖）；</li>\n<li>二级封锁协议：在一级的基础上，事务在读取数据之前必须先加 S 锁，读完后释放。可以解决脏读问题（如果已经有事务在修改数据，就意味着已经加了 X 锁，此时想要读取数据的事务并不能加 S 锁，也就无法进行读取，避免了读取脏数据）；</li>\n<li>三级封锁协议：在二级的基础上，事务在读取数据之前必须先加 S 锁，直到事务结束才能释放。可以解决不可重复读问题（避免了在事务结束前其它事务对数据加 X 锁进行修改，保证了事务期间数据不会被其它事务更新）</li>\n</ul>\n<h3 id=\"什么是两段锁协议\"><a class=\"anchor\" href=\"#什么是两段锁协议\">#</a> 什么是两段锁协议？</h3>\n<p>事务必须严格分为两个阶段对数据进行<strong>加锁和解锁</strong>的操作，第一阶段加锁，第二阶段解锁。也就是说一个事务中一旦释放了锁，就不能再申请新锁了。</p>\n<p><strong>可串行化调度</strong>是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。事务遵循两段锁协议是保证可串行化调度的充分条件。</p>\n<h3 id=\"什么是-mvcc\"><a class=\"anchor\" href=\"#什么是-mvcc\">#</a> 什么是 MVCC？</h3>\n<p>多版本并发控制（Multi-Version Concurrency Control, MVCC），MVCC 在每行记录后面都保存有两个隐藏的列，用来存储<strong>创建版本号</strong>和<strong>删除版本号</strong>。</p>\n<ul>\n<li>创建版本号：创建一个数据行时的事务版本号（<strong>事务版本号</strong>：事务开始时的系统版本号；系统版本号：每开始一个新的事务，系统版本号就会自动递增）；</li>\n<li>删除版本号：删除操作时的事务版本号；</li>\n<li>各种操作：\n<ul>\n<li>插入操作时，记录创建版本号；</li>\n<li>删除操作时，记录删除版本号；</li>\n<li>更新操作时，先记录删除版本号，再新增一行记录创建版本号；</li>\n<li>查询操作时，要符合以下条件才能被查询出来：删除版本号未定义或大于当前事务版本号（删除操作是在当前事务启动之后做的）；创建版本号小于或等于当前事务版本号（创建操作是事务完成或者在事务启动之前完成）</li>\n</ul>\n</li>\n</ul>\n<p>通过版本号减少了锁的争用，<strong>提高了系统性能</strong>；可以实现<strong>提交读</strong>和<strong>可重复读</strong>两种隔离级别，未提交读无需使用 MVCC</p>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 快照读与当前读 &lt;/summary&gt;</p>\n<p>使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销：</p>\n<pre><code>select * from table ...;\n</code></pre>\n<p>当前读读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁：</p>\n<pre><code>select * from table where ? lock in share mode;\nselect * from table where ? for update;\ninsert;\nupdate;\ndelete;\n</code></pre>\n<p>&lt;/details&gt;</p>\n<h3 id=\"数据库的范式\"><a class=\"anchor\" href=\"#数据库的范式\">#</a> 数据库的范式？</h3>\n<ul>\n<li>\n<p><strong>第一范式</strong>（1NF，Normal Form）：<strong>属性不应该是可分的</strong>。举例：如果将 “电话” 作为一个属性（一列），是不符合 1NF 的，因为电话这个属性可以分解为家庭电话和移动电话... 如果将 “移动电话” 作为一个属性，就符合 1NF；</p>\n</li>\n<li>\n<p><strong>第二范式</strong> 2NF：每个非主属性<strong>完全依赖</strong>于主属性集（候选键集）；</p>\n<ul>\n<li>B 完全依赖于 A，就是说 A 中的所有属性唯一决定 B，属性少了就不能唯一决定，属性多了则有冗余（叫依赖不叫完全依赖）。举例：（学号，课程名）这个主属性集可以唯一决定成绩，但是对于学生姓名这个属性，（学号，课程名）这个属性集就是冗余的，所以学生姓名不完全依赖于（学号，课程名）这一属性集；</li>\n<li>主属性集 / 候选码集：某一组属性能够唯一确定其它的属性（主键就是从候选键集中选的一个键），而其子集不能，这样的属性组中的属性就是主属性；不在候选码集中的属性成为非主属性；</li>\n<li>可以通过分解来满足 2NF：将（学号，课程名，成绩）做成一张表；（学号，学生姓名）做成另一张表，避免大量的数据冗余；<br />\n满足 1NF 后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；</li>\n</ul>\n</li>\n<li>\n<p><strong>第三范式</strong> 3NF：在 2NF 的基础上，非主属性<strong>不传递依赖</strong>于主属性</p>\n<ul>\n<li>传递依赖：如果 C 依赖于 B，B 依赖于 A，那么 C 传递依赖于 A；</li>\n<li>3NF 在 2NF 的基础上，消除了非主属性之间的依赖；比如一个表中，主属性有（学号），非主属性有（姓名，院系，院长名），可以看到院长名这个非主属性依赖于院系，传递依赖于学号。消除的办法是分解。<br />\n必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；<br />\n&lt;details&gt;<br />\n&lt;summary&gt; 不符合范式会出现哪些异常？&lt;/summary&gt;</li>\n</ul>\n</li>\n<li>\n<p>冗余数据：某些同样的数据多次出现（如学生姓名）；</p>\n</li>\n<li>\n<p>修改异常：修改了一个记录中的信息，另一个记录中相同的信息却没有修改；</p>\n</li>\n<li>\n<p>删除异常：删除一个信息，那么也会丢失其它信息（删除一个课程，丢失了一个学生的信息）；</p>\n</li>\n<li>\n<p>插入异常：无法插入（插入一个还没有课程信息的学生）<br />\n&lt;/details&gt;</p>\n</li>\n</ul>\n<h3 id=\"列举几种表连接方式\"><a class=\"anchor\" href=\"#列举几种表连接方式\">#</a> 列举几种表连接方式？</h3>\n<p><img data-src=\"_v_images/20191207081711185_20242.png\" alt=\"SQL连接\" /></p>\n<ul>\n<li>内连接（Inner Join）：仅将两个表中满足连接条件的行组合起来作为结果集\n<ul>\n<li>自然连接：只考虑属性相同的元组对；</li>\n<li>等值连接：给定条件进行查询</li>\n</ul>\n</li>\n<li>外连接（Outer Join）\n<ul>\n<li>左连接：左边表的所有数据都有显示出来，右边的表数据只显示共同有的那部分，没有对应的部分补 NULL；</li>\n<li>右连接：和左连接相反；</li>\n<li>全外连接（Full Outer Join）：查询出左表和右表所有数据，但是去除两表的重复数据</li>\n</ul>\n</li>\n<li>交叉连接（Cross Join）：返回两表的笛卡尔积（对于所含数据分别为 m、n 的表，返回 m*n 的结果）</li>\n</ul>\n<h3 id=\"什么是存储过程有哪些优缺点\"><a class=\"anchor\" href=\"#什么是存储过程有哪些优缺点\">#</a> 什么是存储过程？有哪些优缺点？</h3>\n<p>存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合。想要实现相应的功能时，只需要调用这个存储过程就行了（类似于函数，输入具有输出参数）。</p>\n<p>优点：</p>\n<ul>\n<li>预先编译，而不需要每次运行时编译，提高了数据库执行<strong>效率</strong>；</li>\n<li>封装了一系列操作，对于一些数据交互比较多的操作，相比于单独执行 SQL 语句，可以<strong>减少网络通信量</strong>；</li>\n<li>具有<strong>可复用性</strong>，减少了数据库开发的工作量；</li>\n<li><strong>安全性高</strong>，可以让没有权限的用户通过存储过程间接操作数据库；</li>\n<li>更<strong>易于维护</strong></li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li><strong>可移植性差</strong>，存储过程将应用程序绑定到了数据库上；</li>\n<li><strong>开发调试复杂</strong>：没有好的 IDE；</li>\n<li><strong>修改复杂</strong>，需要重新编译，有时还需要更新程序中的代码以更新调用</li>\n</ul>\n<h3 id=\"dropdeletetruncate的区别\"><a class=\"anchor\" href=\"#dropdeletetruncate的区别\">#</a> Drop/Delete/Truncate 的区别？</h3>\n<ul>\n<li><strong>Delete</strong> 用来删除表的全部或者<strong>部分数据</strong>，执行 delete 之后，用户<strong>需要提交</strong>之后才会执行，会触发表上的 DELETE<strong> 触发器</strong>（包含一个 OLD 的虚拟表，可以只读访问被删除的数据），DELETE 之后表结构还在，删除很慢，一行一行地删，因为会记录日志，可以利用日志还原数据；</li>\n<li><strong>Truncate</strong> 删除表中的所有数据，这个操作<strong>不能回滚</strong>，也不会触发这个表上的触发器。操作比 DELETE 快很多（直接把表 drop 掉，再创建一个新表，删除的数据不能找回）。如果表中有自增（AUTO_INCREMENT）列，则重置为 1；</li>\n<li><strong>Drop</strong> 命令从数据库中<strong>删除表</strong>，所有的数据行，索引和约束都会被删除；不能回滚，不会触发触发器；</li>\n</ul>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 什么是触发器？&lt;/summary&gt;</p>\n<p>触发器（TRIGGER）是由事件（比如 INSERT/UPDATE/DELETE）来触发运行的操作（不能被直接调用，不能接收参数）。在数据库里以独立的对象存储，用于<strong>保证数据完整性</strong>（比如可以检验或转换数据）。<br />\n&lt;/details&gt;</p>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 有哪些约束类型？&lt;/summary&gt;</p>\n<p>约束（Constraint）类型：主键（Primary Key）约束，唯一约束（Unique），检查约束，非空约束，外键（Foreign Key）约束。<br />\n&lt;/details&gt;</p>\n<h3 id=\"什么是视图什么是游标\"><a class=\"anchor\" href=\"#什么是视图什么是游标\">#</a> 什么是视图？什么是游标？</h3>\n<ul>\n<li>视图：从数据库的基本表中通过查询选取出来的数据组成的<strong>虚拟表</strong>（数据库中存放视图的定义）。可以对其进行增 / 删 / 改 / 查等操作。视图是对若干张基本表的引用，一张虚表，查询语句执行的结果，不存储具体的数据（基本表数据发生了改变，视图也会跟着改变）；可以跟基本表一样，进行增删改查操作 (ps: 增删改操作有条件限制)；如连表查询产生的视图无法进行，对视图的增删改会影响原表的数据。好处：\n<ul>\n<li>通过只给用户访问视图的权限，保证数据的<strong>安全性</strong>；</li>\n<li><strong>简化</strong>复杂的 SQL 操作，隐藏数据的复杂性（比如复杂的连接）；</li>\n</ul>\n</li>\n<li>游标（Cursor）：用于定位在查询返回的<strong>结果集的特定行</strong>，以对特定行进行操作。使用游标可以方便地对结果集进行移动遍历，根据需要滚动或对浏览 / 修改任意行中的数据。主要用于交互式应用。</li>\n</ul>\n<hr />\n<h3 id=\"数据库索引的实现原理b树\"><a class=\"anchor\" href=\"#数据库索引的实现原理b树\">#</a> 数据库索引的实现原理（B + 树）</h3>\n<p>见<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL3dvbHZlcmlubi9JcmlkZXNjZW50L2Jsb2IvbWFzdGVyL0RhdGElMjBTdHJ1Y3R1cmUubWQjYiVFNiVBMCU5MQ==\">数据结构部分：B 树，B + 树</span></p>\n<h5 id=\"使用b树和b树的比较\"><a class=\"anchor\" href=\"#使用b树和b树的比较\">#</a> 使用 B 树和 B + 树的比较</h5>\n<p>InnoDB 的索引使用的是 B + 树实现，B + 树对比 B 树的好处：</p>\n<ul>\n<li>IO 次数少：B + 树的中间结点只存放索引，数据都存在叶结点中，因此中间结点可以存更多的数据，让索引树更加矮胖；</li>\n<li>范围查询效率更高：B 树需要中序遍历整个树，只 B + 树需要遍历叶结点中的链表；</li>\n<li>查询效率更加稳定：每次查询都需要从根结点到叶结点，路径长度相同，所以每次查询的效率都差不多</li>\n</ul>\n<h5 id=\"使用b树索引和哈希索引的比较\"><a class=\"anchor\" href=\"#使用b树索引和哈希索引的比较\">#</a> 使用 B 树索引和哈希索引的比较</h5>\n<p>哈希索引能以 O (1) 时间进行查找，但是只支持精确查找，无法用于部分查找和范围查找，无法用于排序与分组；B 树索引支持大于小于等于查找，范围查找。哈希索引遇到大量哈希值相等的情况后查找效率会降低。哈希索引不支持数据的排序。</p>\n<h3 id=\"使用索引的优点\"><a class=\"anchor\" href=\"#使用索引的优点\">#</a> 使用索引的优点</h3>\n<ul>\n<li>大大加快了数据的<strong>检索速度</strong>；</li>\n<li>可以显著减少查询中<strong>分组和排序</strong>的时间；</li>\n<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；</li>\n<li>将随机 I/O 变为<strong>顺序 I/O</strong>（B+Tree 索引是有序的，会将相邻的数据都存储在一起）</li>\n</ul>\n<p>缺点：建立和维护索引耗费时间空间，更新索引很慢。</p>\n<h3 id=\"哪些情况下索引会失效\"><a class=\"anchor\" href=\"#哪些情况下索引会失效\">#</a> 哪些情况下索引会失效？</h3>\n<ul>\n<li>以 “%(表示任意 0 个或多个字符)” 开头的 LIKE 语句；</li>\n<li>OR 语句前后没有同时使用索引；</li>\n<li>数据类型出现隐式转化（如 varchar 不加单引号的话可能会自动转换为 int 型）；</li>\n<li>对于多列索引，必须满足 <strong>最左匹配原则</strong> / 最左前缀原则 (最左优先，eg：多列索引 col1、col2 和 col3，则 索引生效的情形包括 col1 或 col1，col2 或 col1，col2，col3)；</li>\n<li>如果 MySQL 估计全表扫描比索引快，则不使用索引（比如非常小的表）</li>\n</ul>\n<h3 id=\"在哪些地方适合创建索引\"><a class=\"anchor\" href=\"#在哪些地方适合创建索引\">#</a> 在哪些地方适合创建索引？</h3>\n<ul>\n<li>某列经常作为最大最小值；</li>\n<li>经常被查询的字段；</li>\n<li>经常用作表连接的字段；</li>\n<li>经常出现在 ORDER BY/GROUP BY/DISDINCT 后面的字段</li>\n</ul>\n<h5 id=\"创建索引时需要注意什么\"><a class=\"anchor\" href=\"#创建索引时需要注意什么\">#</a> 创建索引时需要注意什么？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</p>\n<ul>\n<li>只应建立在<strong>小字段</strong>上，而不要对大文本或图片建立索引（一页存储的数据越多一次 IO 操作获取的数据越大效率越高）；</li>\n<li>建立索引的字段应该<strong>非空</strong>，在 MySQL 中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。应该用 0、一个特殊的值或者一个空串代替 NULL；</li>\n<li>选择<strong>数据密度大</strong>（唯一值占总数的百分比很大）的字段作索引<br />\n &lt;/details&gt;</li>\n</ul>\n<h3 id=\"索引的分类\"><a class=\"anchor\" href=\"#索引的分类\">#</a> 索引的分类？</h3>\n<ul>\n<li>普通索引</li>\n<li>唯一索引 UNIQUE：索引列的值必须唯一，但允许有空值；</li>\n<li>主键索引 PRIMARY KEY：必须唯一，不允许空值（是一种特殊的唯一索引；MySQL 创建主键时默认为聚集索引，但主键也可以是非聚集索引）；</li>\n<li>单列索引和多列索引 / 复合索引（Composite）：索引的列数；</li>\n<li>覆盖（Covering）索引：索引包含了所有满足查询所需要的数据，查询的时候只需要读取索引而不需要回表读取数据；</li>\n<li>聚集（Clustered）索引 / 非聚集索引：对磁盘上存放数据的物理地址重新组织以使这些数据按照指定规则排序的一种索引（数据的物理排列顺序和索引排列顺序一致）。因此每张表只能创建一个聚集索引（因为要改变物理存储顺序）。优点是查询速度快，因为可以直接按照顺序得到需要数据的物理地址。缺点是进行修改的速度较慢。对于需要经常搜索范围的值很有效。非聚集索引只记录逻辑顺序，并不改变物理顺序；</li>\n<li>分区索引（？）</li>\n<li>虚拟索引（Virtual）：模拟索引的存在而不用真正创建一个索引，用于快速测试创建索引对执行计划的影响。没有相关的索引段，不增加存储空间的使用</li>\n</ul>\n<h3 id=\"mysql的两种存储引擎-innodb-和-myisam-的区别\"><a class=\"anchor\" href=\"#mysql的两种存储引擎-innodb-和-myisam-的区别\">#</a> MySQL 的两种存储引擎 InnoDB 和 MyISAM 的区别？</h3>\n<ul>\n<li>InnoDB<strong> 支持事务</strong>，可以进行 Commit 和 Rollback；</li>\n<li>MyISAM 只支持表级锁，而 InnoDB 还<strong>支持行级锁</strong>，提高了并发操作的性能；</li>\n<li>InnoDB <strong>支持外键</strong>；</li>\n<li>MyISAM <strong>崩溃</strong>后发生损坏的概率比 InnoDB 高很多，而且<strong>恢复的速度</strong>也更慢；</li>\n<li>MyISAM 支持<strong>压缩</strong>表和空间数据索引，InnoDB 需要更多的内存和存储；</li>\n<li>InnoDB 支持在线<strong>热备份</strong></li>\n</ul>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 应用场景 &lt;/summary&gt;</p>\n<ul>\n<li><strong>MyISAM</strong> 管理非事务表。它提供高速存储和检索（MyISAM 强调的是性能，每次查询具有原子性，其执行速度比 InnoDB 更快），以及全文搜索能力。如果表比较小，或者是只读数据（有大量的 SELECT），还是可以使用 MyISAM；</li>\n<li><strong>InnoDB</strong> 支持事务，并发情况下有很好的性能，基本可以替代 MyISAM<br />\n&lt;/details&gt;</li>\n</ul>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 热备份和冷备份 &lt;/summary&gt;</p>\n<ul>\n<li>热备份：在数据库运行的情况下备份的方法。优点：可按表或用户备份，备份时数据库仍可使用，可恢复至任一时间点。但是不能出错</li>\n<li>冷备份：数据库正常关闭后，将关键性文件复制到另一位置的备份方式。优点：操作简单快速，恢复简单<br />\n &lt;/details&gt;</li>\n</ul>\n<p>更详细的可以参考：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9pbWFnZXNsci5naXRodWIuaW8vMjAyMC9kYi1lbmdpbmUuaHRtbA==\">MySQL 数据库的存储引擎与适用场景 - Images</span></p>\n<h3 id=\"如何优化数据库\"><a class=\"anchor\" href=\"#如何优化数据库\">#</a> 如何优化数据库？</h3>\n<p>&lt;details&gt;<br />\n&lt;summary&gt;SQL 语句的优化 &lt;/summary&gt;</p>\n<blockquote>\n<p>分析慢查询日志：记录了在 MySQL 中响应时间超过阀值 long_query_time 的 SQL 语句，通过日志去找出 IO 大的 SQL 以及发现未命中索引的 SQL</p>\n</blockquote>\n<blockquote>\n<p>使用 Explain 进行分析：通过 explain 命令可以得到表的读取顺序、数据读取操作的操作类型、哪些索引可以使用、<strong>哪些索引被实际使用</strong>、表之间的引用以及<strong>被扫描的行数</strong>等问题；</p>\n</blockquote>\n<ul>\n<li>应尽量避免在 where 子句中使用 <code>!=</code> 、 <code>&lt;</code> 、 <code>&gt;</code>  操作符或对字段进行 null 值判断，否则将引擎放弃使用索引而进行全表扫描；</li>\n<li>只返回必要的列：最好不要使用 SELECT * 语句；</li>\n<li>只返回必要的行：使用 LIMIT 语句来限制返回的数据；</li>\n<li>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：\n<ul>\n<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用；</li>\n<li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余的查询；</li>\n<li>减少锁竞争<br />\n &lt;/details&gt;</li>\n</ul>\n</li>\n</ul>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 索引的优化 &lt;/summary&gt;</p>\n<p>注意会引起索引失效的情况，以及在适合的地方建立索引<br />\n &lt;/details&gt;</p>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 数据库表结构的优化 &lt;/summary&gt;</p>\n<ul>\n<li>设计表时遵循<strong>三大范式</strong>；</li>\n<li>选择合适的<strong>数据类型</strong>：尽可能不要存储 NULL 字段；使用简单的数据类型（int, varchar/text）；</li>\n<li>表的<strong>水平切分</strong>（Sharding）：将同一个表中的记录拆分到多个结构相同的表中（策略：哈希取模；根据 ID 范围来分）。当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓解单个数据库的压力；</li>\n<li>表的<strong>垂直切分</strong>：将一张表按列切分成多个表。可以将不常用的字段单独放在同一个表中；把大字段独立放入一个表中；或者把经常使用的字段（关系密切的）放在一张表中。垂直切分之后业务更加清晰，系统之间整合或扩展容易，数据维护简单<br />\n &lt;/details&gt;</li>\n</ul>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 系统配置的优化 &lt;/summary&gt;</p>\n<ul>\n<li>操作系统：增加 TCP 支持的队列数；</li>\n<li>MySQL 配置文件优化：缓存池大小和个数设置<br />\n &lt;/details&gt;</li>\n</ul>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 硬件的优化 &lt;/summary&gt;</p>\n<ul>\n<li>磁盘性能：固态硬盘；</li>\n<li>CPU：多核且高频；</li>\n<li>内存：增大内存<br />\n &lt;/details&gt;</li>\n</ul>\n<h3 id=\"什么是主从复制实现原理是什么\"><a class=\"anchor\" href=\"#什么是主从复制实现原理是什么\">#</a> 什么是主从复制？实现原理是什么？</h3>\n<p>主从复制（Replication）是指数据可以从一个 MySQL 数据库主服务器复制到一个或多个从服务器，从服务器可以复制主服务器中的所有数据库或者特定的数据库，或者特定的表。默认采用异步模式。</p>\n<p>实现原理：</p>\n<ul>\n<li>主服务器 <strong>binary log dump 线程</strong>：将主服务器中的数据更改（增删改）日志写入 Binary log 中；</li>\n<li>从服务器 <strong>I/O 线程</strong>：负责从主服务器读取 binary log，并写入本地的 Relay log；</li>\n<li>从服务器 <strong>SQL 线程</strong>：负责读取 Relay log，解析出主服务器已经执行的数据更改，并在从服务器中重新执行（Replay），保证主从数据的一致性</li>\n</ul>\n<h5 id=\"为什么要主从复制\"><a class=\"anchor\" href=\"#为什么要主从复制\">#</a> 为什么要主从复制？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</p>\n<ul>\n<li>读写分离：主服务器负责写，从服务器负责读\n<ul>\n<li>缓解了锁的争用，即使主服务器中加了锁，依然可以进行读操作；</li>\n<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li>\n<li>增加冗余，提高可用性</li>\n</ul>\n</li>\n<li>数据实时备份，当系统中某个节点发生故障时，可以方便的故障切换</li>\n<li>降低单个服务器磁盘 I/O 访问的频率，提高单个机器的 I/O 性能<br />\n &lt;/details&gt;</li>\n</ul>\n<h3 id=\"关系型数据库和非关系型数据库的区别\"><a class=\"anchor\" href=\"#关系型数据库和非关系型数据库的区别\">#</a> 关系型数据库和非关系型数据库的区别？</h3>\n<ul>\n<li>前者高度组织化结构化数据；后者存储的数据结构不固定更加灵活，可以减少一些空间和时间的开销</li>\n<li>后者更加容易水平扩展</li>\n<li>前者支持结构化查询语言，支持复杂的查询功能和表关联。后者只能进行简单的查询</li>\n<li>前者支持事务，具有 ACID 特性。后者则是 BASE，最终一致性</li>\n</ul>\n<h3 id=\"参考\"><a class=\"anchor\" href=\"#参考\">#</a> 参考</h3>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzQzMzAzMi9hcnRpY2xlL2RldGFpbHMvODkyOTM2NjM=\">数据库六大范式详解 -- CSDN 博客</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vYWxpY2UtY2ovcC8xMDM1NDczNy5odG1s\">delete，truncate 和 delete 之间的区别 -- 博客园</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9iYWlqaWFoYW8uYmFpZHUuY29tL3M/aWQ9MTYxNzg4ODc0MDM3MDA5ODg2NiZhbXA7d2ZyPXNwaWRlciZhbXA7Zm9yPXBj\">深度探索 MySQL 主从复制原理</span></li>\n<li>数据库程序员面试笔试宝典 - 机械工业出版社</li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0N5QzIwMTgvQ1MtTm90ZXMvYmxvYi9tYXN0ZXIvbm90ZXMvJUU2JTk1JUIwJUU2JThEJUFFJUU1JUJBJTkzJUU3JUIzJUJCJUU3JUJCJTlGJUU1JThFJTlGJUU3JTkwJTg2Lm1k\">CS-Notes / 数据库系统原理 -- GitHub</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3Rsb3ZleW91Xy9hcnRpY2xlL2RldGFpbHMvNzgzMDg0NjA=\">面试 / 笔试第三弹 —— 数据库面试问题集锦 -- CSDN 博客</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd2VueGlhb2ZlaS9wLzk4NTM2ODIuaHRtbA==\">史上最全的数据库面试题，不看绝对后悔 -- 博客园</span></li>\n</ul>\n<h3 id=\"待完成\"><a class=\"anchor\" href=\"#待完成\">#</a> 待完成</h3>\n<ul class=\"task-list\">\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_0\" disabled=\"true\" /><label for=\"cbx_0\"> E-R 模型</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_1\" disabled=\"true\" /><label for=\"cbx_1\"> 数据库的三级模式和二级映像</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_2\" disabled=\"true\" /><label for=\"cbx_2\"> <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0N5QzIwMTgvQ1MtTm90ZXMvYmxvYi9tYXN0ZXIvbm90ZXMvTXlTUUwubWQjJUU1JTlCJTlCJUU2JTk1JUIwJUU2JThEJUFFJUU3JUIxJUJCJUU1JTlFJThC\">数据类型</span>：VARCHAR 和 CHAR 的区别，DATETIME 和 TIMESATMP 的区别</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_3\" disabled=\"true\" /><label for=\"cbx_3\"> Redis 面试</label>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL0N5QzIwMTgvQ1MtTm90ZXMvYmxvYi9tYXN0ZXIvbm90ZXMvUmVkaXMubWQ=\">CyC2018</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0J1dHRlcmZseV9yZXN0aW5nL2FydGljbGUvZGV0YWlscy84OTY2ODY2MQ==\">几率大的 Redis 面试题（含答案） - CSDN</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC82NTc2NWRkMTA2NzE=\">Redis 面试题总结 - 简书</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vamFzb250ZWMvcC85Njk5MjQyLmh0bWw=\">Redis 常见面试题 - 博客园</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tLzB2b2ljZS9pbnRlcnZpZXdfaW50ZXJuYWxfcmVmZXJlbmNlIzEw\">0voice/interview_internal_reference</span></li>\n</ul>\n</li>\n<li class=\"task-list-item\"><input type=\"checkbox\" id=\"cbx_4\" disabled=\"true\" /><label for=\"cbx_4\"> <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd2VueGlhb2ZlaS9wLzk4NTM2ODIuaHRtbA==\">史上最全的数据库面试题，不看绝对后悔 -- 博客园</span></label></li>\n</ul>\n",
            "tags": [
                "计算机",
                "数据库"
            ]
        },
        {
            "id": "http://example.com/2022/05/15/Computer%20Network/",
            "url": "http://example.com/2022/05/15/Computer%20Network/",
            "title": "计算机网络",
            "date_published": "2022-05-15T11:09:14.000Z",
            "content_html": "<h1 id=\"计算机网络\"><a class=\"anchor\" href=\"#计算机网络\">#</a> 计算机网络</h1>\n<p>&lt;!-- GFM-TOC --&gt;</p>\n<ul>\n<li>传输层：TCP 和 UDP\n<ul>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-three-way-handshake\">什么是三次握手？</a></li>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B\">什么是四次挥手？</a></li>\n<li><a href=\"#TCP%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6\">TCP 如何实现流量控制？</a></li>\n<li><a href=\"#TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84\">TCP 的拥塞控制是怎么实现的？</a></li>\n<li><a href=\"#TCP%E5%A6%82%E4%BD%95%E6%9C%80%E5%A4%A7%E5%88%A9%E7%94%A8%E5%B8%A6%E5%AE%BD\">TCP 如何最大利用带宽？</a></li>\n<li><a href=\"#TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB\">TCP 与 UDP 的区别</a></li>\n<li><a href=\"#TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7\">TCP 如何保证传输的可靠性</a></li>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AFTCP%E7%B2%98%E5%8C%85\"><s>什么是 TCP 粘包？</s></a></li>\n</ul>\n</li>\n<li>应用层：HTTP 和 HTTPS\n<ul>\n<li><a href=\"#HTTP%E5%92%8CHTTPS%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB\">HTTP 和 HTTPS 有什么区别？</a></li>\n<li><a href=\"#GET%E4%B8%8EPOST%E7%9A%84%E5%8C%BA%E5%88%AB\">GET 与 POST 的区别？</a></li>\n<li><a href=\"#Session%E4%B8%8ECookie%E7%9A%84%E5%8C%BA%E5%88%AB\">Session 与 Cookie 的区别？</a></li>\n<li><a href=\"#%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E8%8E%B7%E5%BE%97%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BF%87%E7%A8%8B-%E8%B6%8A%E8%AF%A6%E7%BB%86%E8%B6%8A%E5%A5%BD\">从输入网址到获得页面的过程 (越详细越好)？</a></li>\n<li><a href=\"#HTTP%E8%AF%B7%E6%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81\">HTTP 请求有哪些常见状态码？</a></li>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AFRIP-Routing-Information-Protocol-%E8%B7%9D%E7%A6%BB%E7%9F%A2%E9%87%8F%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE-%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88\">什么是 RIP (距离矢量路由协议)?</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84\">计算机网络体系结构</a></li>\n<li>网络层协议\n<ul>\n<li><a href=\"#IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB\">IP 地址的分类？</a></li>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E5%8F%AB%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91\">什么叫划分子网？</a></li>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AFARP%E5%8D%8F%E8%AE%AE-Address-Resolution-Protocol\">什么是 ARP 协议？</a></li>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AFNAT-Network-Address-Translation-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2\">什么是 NAT (网络地址转换)？</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%8F%82%E8%80%83\">参考</a><br />\n &lt;!-- GFM-TOC --&gt;</li>\n</ul>\n<hr />\n<h3 id=\"什么是三次握手-three-way-handshake\"><a class=\"anchor\" href=\"#什么是三次握手-three-way-handshake\">#</a> 什么是三次握手 (three-way handshake)？</h3>\n<p><img data-src=\"_v_images/20191129101827556_21212.png\" alt=\"三次握手\" /></p>\n<ul>\n<li>第一次握手：Client 将 SYN 置 1，随机产生一个初始序列号 seq 发送给 Server，进入 SYN_SENT 状态；</li>\n<li>第二次握手：Server 收到 Client 的 SYN=1 之后，知道客户端请求建立连接，将自己的 SYN 置 1，ACK 置 1，产生一个 acknowledge number=sequence number+1，并随机产生一个自己的初始序列号，发送给客户端；进入 SYN_RCVD 状态；</li>\n<li>第三次握手：客户端检查 acknowledge number 是否为序列号 + 1，ACK 是否为 1，检查正确之后将自己的 ACK 置为 1，产生一个 acknowledge number = 服务器发的序列号 + 1，发送给服务器；进入 ESTABLISHED 状态；服务器检查 ACK 为 1 和 acknowledge number 为序列号 + 1 之后，也进入 ESTABLISHED 状态；完成三次握手，连接建立。</li>\n</ul>\n<h5 id=\"tcp建立连接可以两次握手吗为什么\"><a class=\"anchor\" href=\"#tcp建立连接可以两次握手吗为什么\">#</a> TCP 建立连接可以两次握手吗？为什么？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</p>\n<p>不可以。有两个原因：</p>\n<p>首先，可能会出现<strong>已失效的连接请求报文段又传到了服务器端</strong>。</p>\n<blockquote>\n<p>client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。</p>\n</blockquote>\n<p>其次，两次握手无法保证 Client 正确接收第二次握手的报文（Server 无法确认 Client 是否收到），也无法保证 Client 和 Server 之间成功互换初始序列号。<br />\n&lt;/details&gt;</p>\n<h5 id=\"可以采用四次握手吗为什么\"><a class=\"anchor\" href=\"#可以采用四次握手吗为什么\">#</a> 可以采用四次握手吗？为什么？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</p>\n<p>可以。但是会降低传输的效率。</p>\n<p>四次握手是指：第二次握手：Server 只发送 ACK 和 acknowledge number；而 Server 的 SYN 和初始序列号在第三次握手时发送；原来协议中的第三次握手变为第四次握手。出于优化目的，四次握手中的二、三可以合并。<br />\n&lt;/details&gt;</p>\n<h5 id=\"第三次握手中如果客户端的ack未送达服务器会怎样\"><a class=\"anchor\" href=\"#第三次握手中如果客户端的ack未送达服务器会怎样\">#</a> 第三次握手中，如果客户端的 ACK 未送达服务器，会怎样？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</p>\n<p>Server 端：<br />\n由于 Server 没有收到 ACK 确认，因此会重发之前的 SYN+ACK（默认重发五次，之后自动关闭连接进入 CLOSED 状态），Client 收到后会重新传 ACK 给 Server。</p>\n<p>Client 端，两种情况：</p>\n<ol>\n<li>在 Server 进行超时重发的过程中，如果 Client 向服务器发送数据，数据头部的 ACK 是为 1 的，所以服务器收到数据之后会读取 ACK number，进入 establish 状态</li>\n<li>在 Server 进入 CLOSED 状态之后，如果 Client 向服务器发送数据，服务器会以 RST 包应答。<br />\n&lt;/details&gt;</li>\n</ol>\n<h5 id=\"如果已经建立了连接但客户端出现了故障怎么办\"><a class=\"anchor\" href=\"#如果已经建立了连接但客户端出现了故障怎么办\">#</a> 如果已经建立了连接，但客户端出现了故障怎么办？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</p>\n<p>服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为 2 小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔 75 秒钟发送一次。若一连发送 10 个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。<br />\n&lt;/details&gt;</p>\n<h5 id=\"初始序列号是什么\"><a class=\"anchor\" href=\"#初始序列号是什么\">#</a> 初始序列号是什么？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</p>\n<p>TCP 连接的一方 A，随机选择一个 32 位的序列号（Sequence Number）作为发送数据的初始序列号（Initial Sequence Number，ISN），比如为 1000，以该序列号为原点，对要传送的数据进行编号：1001、1002... 三次握手时，把这个初始序列号传送给另一方 B，以便在传输数据时，B 可以确认什么样的数据编号是合法的；同时在进行数据传输时，A 还可以确认 B 收到的每一个字节，如果 A 收到了 B 的确认编号（acknowledge number）是 2001，就说明编号为 1001-2000 的数据已经被 B 成功接受。<br />\n&lt;/details&gt;</p>\n<h3 id=\"什么是四次挥手\"><a class=\"anchor\" href=\"#什么是四次挥手\">#</a> 什么是四次挥手？</h3>\n<p><img data-src=\"_v_images/20191129112652915_15481.png\" alt=\"四次挥手\" /></p>\n<ul>\n<li>第一次挥手：Client 将 FIN 置为 1，发送一个序列号 seq 给 Server；进入 FIN_WAIT_1 状态；</li>\n<li>第二次挥手：Server 收到 FIN 之后，发送一个 ACK=1，acknowledge number = 收到的序列号 + 1；进入 CLOSE_WAIT 状态。此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。</li>\n<li>第三次挥手：Server 将 FIN 置 1，发送一个序列号给 Client；进入 LAST_ACK 状态；</li>\n<li>第四次挥手：Client 收到服务器的 FIN 后，进入 TIME_WAIT 状态；接着将 ACK 置 1，发送一个 acknowledge number = 序列号 + 1 给服务器；服务器收到后，确认 acknowledge number 后，变为 CLOSED 状态，不再向客户端发送数据。客户端等待 2*MSL（报文段最长寿命）时间后，也进入 CLOSED 状态。完成四次挥手。</li>\n</ul>\n<h5 id=\"为什么不能把服务器发送的ack和fin合并起来变成三次挥手close_wait状态意义是什么\"><a class=\"anchor\" href=\"#为什么不能把服务器发送的ack和fin合并起来变成三次挥手close_wait状态意义是什么\">#</a> 为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手（CLOSE_WAIT 状态意义是什么）？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</p>\n<p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。<br />\n&lt;/details&gt;</p>\n<h5 id=\"如果第二次挥手时服务器的ack没有送达客户端会怎样\"><a class=\"anchor\" href=\"#如果第二次挥手时服务器的ack没有送达客户端会怎样\">#</a> 如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</p>\n<p>客户端没有收到 ACK 确认，会重新发送 FIN 请求。<br />\n&lt;/details&gt;</p>\n<h5 id=\"客户端time_wait状态的意义是什么\"><a class=\"anchor\" href=\"#客户端time_wait状态的意义是什么\">#</a> 客户端 TIME_WAIT 状态的意义是什么？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</p>\n<p>第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，TIME_WAIT 状态就是用来重发可能丢失的 ACK 报文。如果 Server 没有收到 ACK，就会重发 FIN，如果 Client 在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。</p>\n<p>MSL (Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。<br />\n&lt;/details&gt;</p>\n<h3 id=\"tcp如何实现流量控制\"><a class=\"anchor\" href=\"#tcp如何实现流量控制\">#</a> TCP 如何实现流量控制？</h3>\n<p><img data-src=\"_v_images/20191129145400104_2106.png\" alt=\"滑动窗口\" /></p>\n<p>使用滑动窗口协议实现流量控制。防止发送方发送速率太快，接收方缓存区不够导致溢出。接收方会维护一个接收窗口 receiver window（窗口大小单位是字节），接受窗口的大小是根据自己的资源情况动态调整的，在返回 ACK 时将接受窗口大小放在 TCP 报文中的窗口字段告知发送方。发送窗口的大小不能超过接受窗口的大小，只有当发送方发送并收到确认之后，才能将发送窗口右移。</p>\n<p>发送窗口的上限为接受窗口和拥塞窗口中的较小值。接受窗口表明了接收方的接收能力，拥塞窗口表明了网络的传送能力。</p>\n<p><img data-src=\"_v_images/1615897397.gif\" alt=\"滑动窗口\" /></p>\n<h5 id=\"什么是零窗口接收窗口为0时会怎样\"><a class=\"anchor\" href=\"#什么是零窗口接收窗口为0时会怎样\">#</a> 什么是零窗口（接收窗口为 0 时会怎样）？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</p>\n<p>如果接收方没有能力接收数据，就会将接收窗口设置为 0，这时发送方必须暂停发送数据，但是会启动一个持续计时器 (persistence timer)，到期后发送一个大小为 1 字节的探测数据包，以查看接收窗口状态。如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据传送。<br />\n&lt;/details&gt;</p>\n<h3 id=\"tcp的拥塞控制是怎么实现的\"><a class=\"anchor\" href=\"#tcp的拥塞控制是怎么实现的\">#</a> TCP 的拥塞控制是怎么实现的？</h3>\n<p><img data-src=\"_v_images/20191129153624025_28293.png\" alt=\"拥塞控制\" /></p>\n<p>拥塞控制主要由四个算法组成：<strong>慢启动（Slow Start）、拥塞避免（Congestion voidance）、快重传 （Fast Retransmit）、快恢复（Fast Recovery）</strong></p>\n<ol>\n<li>慢启动：刚开始发送数据时，先把拥塞窗口（congestion window）设置为一个最大报文段 MSS 的数值，每收到一个新的确认报文之后，就把拥塞窗口加 1 个 MSS。这样每经过一个传输轮次（或者说是每经过一个往返时间 RTT），拥塞窗口的大小就会加倍</li>\n</ol>\n<p><img data-src=\"_v_images/20191129155345024_11142.png\" alt=\"slow start\" /></p>\n<ol start=\"2\">\n<li>拥塞避免：当拥塞窗口的大小达到慢开始门限 (slow start threshold) 时，开始执行拥塞避免算法，拥塞窗口大小不再指数增加，而是线性增加，即每经过一个传输轮次只增加 1MSS.</li>\n</ol>\n<blockquote>\n<p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限 ssthresh 设置为出现拥塞时的发送方窗口值的一半（但不能小于 2）。然后把拥塞窗口 cwnd 重新设置为 1，执行慢开始算法。<strong>（这是不使用快重传的情况）</strong></p>\n</blockquote>\n<ol start=\"3\">\n<li>快重传：快重传要求接收方在收到一个失序的报文段后就立即发出<strong>重复确认</strong>（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</li>\n</ol>\n<p><img data-src=\"_v_images/20191129161026032_32431.png\" alt=\"快重传\" /></p>\n<ol start=\"4\">\n<li>快恢复：当发送方连续收到三个重复确认时，就把慢开始门限减半，然后执行拥塞避免算法。不执行慢开始算法的原因：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方认为现在网络可能没有出现拥塞。<br />\n也有的快重传是把开始时的拥塞窗口 cwnd 值再增大一点，即等于 ssthresh + 3*MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络的资源而是停留在接收方的缓存中。可见现在网络中减少了三个分组。因此可以适当把拥塞窗口扩大些。</li>\n</ol>\n<h3 id=\"tcp如何最大利用带宽\"><a class=\"anchor\" href=\"#tcp如何最大利用带宽\">#</a> TCP 如何最大利用带宽？</h3>\n<p>TCP 速率受到三个因素影响</p>\n<ul>\n<li>窗口：即滑动窗口大小，见<a href=\"#TCP%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6\"> TCP 如何实现流量控制？</a></li>\n<li>带宽：这里带宽是指单位时间内从发送端到接收端所能通过的 “最高数据率”，是一种硬件限制。TCP 发送端和接收端的数据传输数不可能超过两点间的带宽限制。发送端和接收端之间带宽取所通过线路的带宽最小值（如通过互联网连接）。</li>\n<li>RTT：即 Round Trip Time，表示从发送端到接收端的一去一回需要的时间，TCP 在数据传输过程中会对 RTT 进行采样（即对发送的数据包及其 ACK 的时间差进行测量，并根据测量值更新 RTT 值），TCP 根据得到的 RTT 值更新 RTO 值，即 Retransmission TimeOut，就是重传间隔，发送端对每个发出的数据包进行计时，如果在 RTO 时间内没有收到所发出的数据包的对应 ACK，则任务数据包丢失，将重传数据。一般 RTO 值都比采样得到的 RTT 值要大。</li>\n</ul>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 带宽时延乘积 &lt;/summary&gt;</p>\n<p>带宽时延乘积 = 带宽 * RTT，实际上等于发送端到接收端单向通道的数据容积的两倍，这里单向通道的数据容积可以这样来理解，单向通道看成是一条单行道马路，带宽就是马路的车道数，路上跑的汽车就是数据（不过这里所有汽车的速率都是一样的，且不会有人想超车，大家齐头并进），那么单向通道的数据容积就是这条单行道上摆满车，一共可以摆多少辆。带宽就是马路的车道数，带宽数乘以单向通道的数据容积就是路面上所能容纳的全部数据量。当路面上已经摆满的时候，就不能再往里面放了。<br />\n&lt;/details&gt;</p>\n<p>设滑动窗口大小为<img data-src=\"https://latex.codecogs.com/svg.latex?W\" alt=\"\" />， 发送端和接收端的带宽为<img data-src=\"https://latex.codecogs.com/svg.latex?B\" alt=\"\" />， RTT 为<img data-src=\"https://latex.codecogs.com/svg.latex?T_r\" alt=\"\" />。</p>\n<p>前面已经说过了，TCP 发送数据时受滑动窗口的限制，当 TCP 将滑动窗口中的数据都发出后，在收到第一个 ACK 之前，滑动窗口大小是 0，不能再发送数据了，必须等待 ACK 包使滑动窗口移动。那么在理想情况下，ACK 包应该在什么时候到达呢？显然，就是在数据发出后的 RTT 时间后，ACK 包到达。这也就是说，现在在不考虑丢包和拥塞情况下，TCP 在一个 RTT 时间内能发出的最大数据量为 <img data-src=\"http://latex.codecogs.com/gif.latex?W\" alt=\"\" /> ，所以不考虑带宽限制下，TCP 能一个时刻能达到的最大速度是 <img data-src=\"https://latex.codecogs.com/svg.latex?V=%5Cfrac%7BW%7D%7BT_r%7D\" alt=\"\" />。</p>\n<p>现在再考虑带宽限制，前面说过当马路上摆满车的时候，就无法再往里放车了，同理，TCP 发送端在 <img data-src=\"https://latex.codecogs.com/svg.latex?%5Cfrac%7BT_r%7D%7B2%7D\" alt=\"\" /> 时间内，能往通道上放的最大数据量为 <img data-src=\"https://latex.codecogs.com/svg.latex?%5Cfrac%7BV*T_r%7D%7B2%7D\" alt=\"\" /> ，通过带宽时延乘积得到的容积限制为 <img data-src=\"https://latex.codecogs.com/svg.latex?%5Cfrac%7BB*T_r%7D%7B2%7D\" alt=\"\" />。当 <img data-src=\"https://latex.codecogs.com/svg.latex?%5Cfrac%7BB*T_r%7D%7B2%7D%20%5Cgeq%20%5Cfrac%7BV*T_r%7D%7B2%7D\" alt=\"\" /> 时，单向通道容积不构成瓶颈，速率的限制主要来源于窗口大小限制。而当 <img data-src=\"https://latex.codecogs.com/svg.latex?%5Cfrac%7BV*T_r%7D%7B2%7D%20%5Cgeq%20%5Cfrac%7BB*T_r%7D%7B2%7D\" alt=\"\" /> 时，则就受到容积限制，即此时速率限制来源于带宽限制。</p>\n<p>因此，TCP 的最大速率为 <img data-src=\"https://latex.codecogs.com/svg.latex?V%20=%20%5Cmin%7B(%5Cfrac%7BW%7D%7BT_r%7D,%20B)%7D\" alt=\"\" /></p>\n<p>在我们平时生活中使用的宽带网络，ADSL 等环境下，因为带宽都比较小，从而 <img data-src=\"https://latex.codecogs.com/svg.latex?B*T_r\" alt=\"\" /> 也比较小，再加上网络情况比较复杂，拥塞情况比较常见，所以这些网络环境下，TCP 速率的主要限制因素在于带宽，丢包率等。长肥管道一般不太常见，多见于一些单位使用的专线网络，在这些网络中速率的主要限制因素就是窗口大小了，这也是传统 TCP 在这些网络环境中不能充分利用带宽的原因所在（因为传统 TCP 的窗口大小是用 2 字节表示的，所以最大只有 65535（不考虑窗口扩大选项）），除了专线网络外，随着网络硬件技术的发展，万兆交换机的出现，局域网中也可能会出现带宽时延乘积较大的情况。</p>\n<h3 id=\"tcp与udp的区别\"><a class=\"anchor\" href=\"#tcp与udp的区别\">#</a> TCP 与 UDP 的区别</h3>\n<ol>\n<li>TCP 是面向连接的，UDP 是无连接的；<br />\n&lt;details&gt;<br />\n&lt;summary&gt; 什么叫无连接？&lt;/summary&gt;</li>\n</ol>\n<p>UDP 发送数据之前不需要建立连接<br />\n &lt;/details&gt;</p>\n<ol start=\"2\">\n<li>TCP 是可靠的，UDP 不可靠；<br />\n&lt;details&gt;<br />\n&lt;summary&gt; 什么叫不可靠？&lt;/summary&gt;</li>\n</ol>\n<p>UDP 接收方收到报文后，不需要给出任何确认<br />\n &lt;/details&gt;</p>\n<ol start=\"3\">\n<li>TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</li>\n<li>TCP 是面向字节流的，UDP 是面向报文的；<br />\n&lt;details&gt;<br />\n&lt;summary&gt; 什么意思？&lt;/summary&gt;</li>\n</ol>\n<p>面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而 UDP 一个报文只能一次发完。<br />\n&lt;/details&gt;</p>\n<ol start=\"5\">\n<li>TCP 有拥塞控制机制，UDP 没有。网络出现的拥塞不会使源主机的发送速率降低，这对某些实时应用是很重要的，比如媒体通信，游戏；</li>\n<li>TCP 首部开销（20 字节）比 UDP 首部开销（8 字节）要大</li>\n<li>UDP 的主机不需要维持复杂的连接状态表</li>\n</ol>\n<h5 id=\"什么时候选择tcp什么时候选udp\"><a class=\"anchor\" href=\"#什么时候选择tcp什么时候选udp\">#</a> 什么时候选择 TCP，什么时候选 UDP？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;<br />\n 对某些实时性要求比较高的情况，选择 UDP，比如游戏，媒体通信，实时视频流（直播），即使出现传输错误也可以容忍；其它大部分情况下，HTTP 都是用 TCP，因为要求传输的内容可靠，不出现丢失<br />\n &lt;/details&gt;</p>\n<h5 id=\"http可以使用udp吗\"><a class=\"anchor\" href=\"#http可以使用udp吗\">#</a> HTTP 可以使用 UDP 吗？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;<br />\nHTTP 不可以使用 UDP，HTTP 需要基于可靠的传输协议，而 UDP 不可靠</p>\n<p>注：<strong>http 3.0 使用 udp 实现</strong><br />\n<span class=\"exturl\" data-url=\"aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvSFRUUC8z\"> https://zh.wikipedia.org/wiki/HTTP/3</span><br />\n&lt;/details&gt;</p>\n<h5 id=\"面向连接和无连接的区别\"><a class=\"anchor\" href=\"#面向连接和无连接的区别\">#</a> 面向连接和无连接的区别</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</p>\n<p>无连接的网络服务（数据报服务）-- 面向连接的网络服务（虚电路服务）</p>\n<p>虚电路服务：首先建立连接，所有的数据包经过相同的路径，服务质量有较好的保证；</p>\n<p>数据报服务：每个数据包含目的地址，数据路由相互独立（路径可能变化）；网络尽最大努力交付数据，但不保证不丢失、不保证先后顺序、不保证在时限内交付；网络发生拥塞时，可能会将一些分组丢弃；</p>\n<p><img data-src=\"_v_images/20191201081919108_30577.png\" alt=\"virtual circuit\" /><br />\n&lt;/details&gt;</p>\n<h3 id=\"tcp如何保证传输的可靠性\"><a class=\"anchor\" href=\"#tcp如何保证传输的可靠性\">#</a> TCP 如何保证传输的可靠性</h3>\n<ol>\n<li>数据包校验</li>\n<li>对失序数据包重新排序（TCP 报文具有序列号）</li>\n<li>丢弃重复数据</li>\n<li>应答机制：接收方收到数据之后，会发送一个确认（通常延迟几分之一秒）；</li>\n<li>超时重发：发送方发出数据之后，启动一个定时器，超时未收到接收方的确认，则重新发送这个数据；</li>\n<li>流量控制：确保接收端能够接收发送方的数据而不会缓冲区溢出</li>\n</ol>\n<h3 id=\"http和https有什么区别\"><a class=\"anchor\" href=\"#http和https有什么区别\">#</a> HTTP 和 HTTPS 有什么区别？</h3>\n<ol>\n<li>端口不同：HTTP 使用的是 80 端口，HTTPS 使用 443 端口；</li>\n<li>HTTP（超文本传输协议）信息是明文传输，HTTPS 运行在 SSL (Secure Socket Layer) 之上，添加了加密和认证机制，更加安全；</li>\n<li>HTTPS 由于加密解密会带来更大的 CPU 和内存开销；</li>\n<li>HTTPS 通信需要证书，一般需要向证书颁发机构（CA）购买</li>\n</ol>\n<h5 id=\"https的连接过程\"><a class=\"anchor\" href=\"#https的连接过程\">#</a> Https 的连接过程？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</p>\n<ol>\n<li>客户端向服务器发送请求，同时发送客户端支持的一套加密规则（包括对称加密、非对称加密、摘要算法）；</li>\n<li>服务器从中选出一组加密算法与 HASH 算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，<strong>加密公钥</strong>（用于非对称加密），以及证书的颁发机构等信息（证书中的私钥只能用于服务器端进行解密）；</li>\n<li>客户端验证服务器的合法性，包括：证书是否过期，CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的 “发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配；</li>\n<li>如果证书受信任，或者用户接收了不受信任的证书，浏览器会生成一个<strong>随机密钥</strong>（用于对称算法），并用服务器提供的公钥加密（采用非对称算法对密钥加密）；使用 Hash 算法对握手消息进行<strong>摘要</strong>计算，并对摘要使用之前产生的密钥加密（对称算法）；将加密后的随机密钥和摘要一起发送给服务器；</li>\n<li>服务器使用自己的私钥解密，得到对称加密的密钥，用这个密钥解密出 Hash 摘要值，并验证握手消息是否一致；如果一致，服务器使用对称加密的密钥加密握手消息发给浏览器；</li>\n<li>浏览器解密并验证摘要，若一致，则握手结束。之后的数据传送都使用对称加密的密钥进行加密</li>\n</ol>\n<p>总结：非对称加密算法用于在握手过程中加密生成的密码；对称加密算法用于对真正传输的数据进行加密；HASH 算法用于验证数据的完整性。<br />\n&lt;/details&gt;</p>\n<h5 id=\"输入-wwwbaiducom怎么变成-httpswwwbaiducom-的怎么确定用http还是https\"><a class=\"anchor\" href=\"#输入-wwwbaiducom怎么变成-httpswwwbaiducom-的怎么确定用http还是https\">#</a> 输入 <span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5iYWlkdS5jb20=\">www.baidu.com</span>，怎么变成 <span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmFpZHUuY29t\">https://www.baidu.com</span> 的，怎么确定用 HTTP 还是 HTTPS？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuc29odS5jb20vYS8xMzY2Mzc4NzZfNDg3NTE2\">你访问的网站是如何自动切换到 HTTPS 的？</span></p>\n<p>一种是原始的 302 跳转，服务器把所有的 HTTp 流量跳转到 HTTPS。但这样有一个漏洞，就是中间人可能在第一次访问站点的时候就劫持。<br />\n解决方法是引入 HSTS 机制，用户浏览器在访问站点的时候强制使用 HTTPS。<br />\n&lt;/details&gt;</p>\n<h5 id=\"https连接的时候怎么确定收到的包是服务器发来的中间人攻击\"><a class=\"anchor\" href=\"#https连接的时候怎么确定收到的包是服务器发来的中间人攻击\">#</a> HTTPS 连接的时候，怎么确定收到的包是服务器发来的（中间人攻击）？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;<br />\n1. 验证域名、有效期等信息是否正确。证书上都有包含这些信息，比较容易完成验证；</p>\n<p>2. 判断证书来源是否合法。每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发证书完成来源验证；</p>\n<p>3. 判断证书是否被篡改。需要与 CA 服务器进行校验；</p>\n<p>4. 判断证书是否已吊销。通过 CRL（Certificate Revocation List 证书注销列表）和 OCSP（Online Certificate Status Protocol 在线证书状态协议）实现，其中 OCSP 可用于第 3 步中以减少与 CA 服务器的交互，提高验证效率</p>\n<p>&lt;/details&gt;</p>\n<h5 id=\"什么是对称加密-非对称加密区别是什么\"><a class=\"anchor\" href=\"#什么是对称加密-非对称加密区别是什么\">#</a> 什么是对称加密、非对称加密？区别是什么？</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</p>\n<ul>\n<li>对称加密：加密和解密采用相同的密钥。如：DES、RC2、RC4</li>\n<li>非对称加密：需要两个密钥：公钥和私钥。如果用公钥加密，需要用私钥才能解密。如：RSA</li>\n<li>区别：对称加密速度更快，通常用于大量数据的加密；非对称加密安全性更高（不需要传送私钥）<br />\n&lt;/details&gt;</li>\n</ul>\n<h5 id=\"数字签名-报文摘要的原理\"><a class=\"anchor\" href=\"#数字签名-报文摘要的原理\">#</a> 数字签名、报文摘要的原理</h5>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 展开 &lt;/summary&gt;</p>\n<ul>\n<li>发送者 A 用私钥进行签名，接收者 B 用公钥验证签名。因为除 A 外没有人有私钥，所以 B 相信签名是来自 A。A 不可抵赖，B 也不能伪造报文。</li>\n<li>摘要算法：MD5、SHA<br />\n&lt;/details&gt;</li>\n</ul>\n<h3 id=\"get与post的区别\"><a class=\"anchor\" href=\"#get与post的区别\">#</a> GET 与 POST 的区别？</h3>\n<ol>\n<li>GET 是幂等的，即读取同一个资源，总是得到相同的数据，POST 不是幂等的；</li>\n<li>GET 一般用于从服务器获取资源，而 POST 有可能改变服务器上的资源；</li>\n<li>请求形式上：GET 请求的数据附在 URL 之后，在 HTTP 请求头中；POST 请求的数据在请求体中；</li>\n<li>安全性：GET 请求可被缓存、收藏、保留到历史记录，且其请求数据明文出现在 URL 中。POST 的参数不会被保存，安全性相对较高；</li>\n<li>GET 只允许 ASCII 字符，POST 对数据类型没有要求，也允许二进制数据；</li>\n<li>GET 的长度有限制（操作系统或者浏览器），而 POST 数据大小无限制</li>\n</ol>\n<h3 id=\"session与cookie的区别\"><a class=\"anchor\" href=\"#session与cookie的区别\">#</a> Session 与 Cookie 的区别？</h3>\n<p>Session 是服务器端保持状态的方案，Cookie 是客户端保持状态的方案</p>\n<p>Cookie 保存在客户端本地，客户端请求服务器时会将 Cookie 一起提交；Session 保存在服务端，通过检索 Sessionid 查看状态。保存 Sessionid 的方式可以采用 Cookie，如果禁用了 Cookie，可以使用 URL 重写机制（把会话 ID 保存在 URL 中）。</p>\n<h3 id=\"从输入网址到获得页面的过程-越详细越好\"><a class=\"anchor\" href=\"#从输入网址到获得页面的过程-越详细越好\">#</a> 从输入网址到获得页面的过程 (越详细越好)？</h3>\n<ol>\n<li>浏览器查询 DNS，获取域名对应的 IP 地址：具体过程包括浏览器搜索自身的 DNS 缓存、搜索操作系统的 DNS 缓存、读取本地的 Host 文件和向本地 DNS 服务器进行查询等。对于向本地 DNS 服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析 (此解析具有权威性)；如果要查询的域名不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；</li>\n<li>浏览器获得域名对应的 IP 地址以后，浏览器向服务器请求建立链接，发起三次握手；</li>\n<li>TCP/IP 链接建立起来后，浏览器向服务器发送 HTTP 请求；</li>\n<li>服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</li>\n<li>浏览器解析并渲染视图，若遇到对 js 文件、css 文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；</li>\n<li>浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</li>\n</ol>\n<h3 id=\"http请求有哪些常见状态码\"><a class=\"anchor\" href=\"#http请求有哪些常见状态码\">#</a> HTTP 请求有哪些常见状态码？</h3>\n<ol>\n<li>2xx 状态码：操作成功。200 OK</li>\n<li>3xx 状态码：重定向。301 永久重定向；302 暂时重定向</li>\n<li>4xx 状态码：客户端错误。400 Bad Request；401 Unauthorized；403 Forbidden；404 Not Found；</li>\n<li>5xx 状态码：服务端错误。500 服务器内部错误；501 服务不可用</li>\n</ol>\n<h3 id=\"什么是rip-routing-information-protocol-距离矢量路由协议-算法是什么\"><a class=\"anchor\" href=\"#什么是rip-routing-information-protocol-距离矢量路由协议-算法是什么\">#</a> 什么是 RIP (Routing Information Protocol, 距离矢量路由协议)? 算法是什么？</h3>\n<p>每个路由器维护一张表，记录该路由器到其它网络的” 跳数 “，路由器到与其直接连接的网络的跳数是 1，每多经过一个路由器跳数就加 1；更新该表时和相邻路由器交换路由信息；路由器允许一个路径最多包含 15 个路由器，如果跳数为 16，则不可达。交付数据报时优先选取距离最短的路径。</p>\n<p>（PS：RIP 是应用层协议：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzE5NjQ1NDA3\">https://www.zhihu.com/question/19645407</span>）</p>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 优缺点 &lt;/summary&gt;</p>\n<ul>\n<li>实现简单，开销小</li>\n<li>随着网络规模扩大开销也会增大；</li>\n<li>最大距离为 15，限制了网络的规模；</li>\n<li>当网络出现故障时，要经过较长的时间才能将此信息传递到所有路由器<br />\n &lt;/details&gt;</li>\n</ul>\n<h3 id=\"计算机网络体系结构\"><a class=\"anchor\" href=\"#计算机网络体系结构\">#</a> 计算机网络体系结构</h3>\n<p><img data-src=\"_v_images/20191129195451183_16713.png\" alt=\"计算机网络体系结构\" /></p>\n<ul>\n<li>Physical, Data Link, Network, Transport, Application</li>\n<li>应用层：常见协议：\n<ul>\n<li>FTP (21 端口)：文件传输协议</li>\n<li>SSH (22 端口)：远程登陆</li>\n<li>TELNET (23 端口)：远程登录</li>\n<li>SMTP (25 端口)：发送邮件</li>\n<li>POP3 (110 端口)：接收邮件</li>\n<li>HTTP (80 端口)：超文本传输协议</li>\n<li>DNS (53 端口)：运行在 UDP 上，域名解析服务</li>\n</ul>\n</li>\n<li>传输层：TCP/UDP</li>\n<li>网络层：IP、ARP、NAT、RIP...</li>\n</ul>\n<p>&lt;details&gt;<br />\n&lt;summary&gt; 路由器、交换机位于哪一层？&lt;/summary&gt;</p>\n<ul>\n<li>路由器网络层，根据 IP 地址进行寻址；</li>\n<li>交换机数据链路层，根据 MAC 地址进行寻址<br />\n &lt;/details&gt;</li>\n</ul>\n<h3 id=\"ip地址的分类\"><a class=\"anchor\" href=\"#ip地址的分类\">#</a> IP 地址的分类？</h3>\n<p><img data-src=\"_v_images/20191201085151639_2895.png\" alt=\"IP address\" /></p>\n<p>路由器仅根据网络号 net-id 来转发分组，当分组到达目的网络的路由器之后，再按照主机号 host-id 将分组交付给主机；同一网络上的所有主机的网络号相同。</p>\n<h3 id=\"什么叫划分子网\"><a class=\"anchor\" href=\"#什么叫划分子网\">#</a> 什么叫划分子网？</h3>\n<p>从主机号 host-id 借用若干个比特作为子网号 subnet-id；子网掩码：网络号和子网号都为 1，主机号为 0；数据报仍然先按照网络号找到目的网络，发送到路由器，路由器再按照网络号和子网号找到目的子网：将子网掩码与目标地址逐比特与操作，若结果为某个子网的网络地址，则送到该子网。</p>\n<h3 id=\"什么是arp协议-address-resolution-protocol\"><a class=\"anchor\" href=\"#什么是arp协议-address-resolution-protocol\">#</a> 什么是 ARP 协议 (Address Resolution Protocol)？</h3>\n<p><strong>ARP 协议完成了 IP 地址与物理地址的映射</strong>。每一个主机都设有一个 ARP 高速缓存，里面有<strong>所在的局域网</strong>上的各主机和路由器的 IP 地址到硬件地址的映射表。当源主机要发送数据包到目的主机时，会先检查自己的 ARP 高速缓存中有没有目的主机的 MAC 地址，如果有，就直接将数据包发到这个 MAC 地址，如果没有，就向<strong>所在的局域网</strong>发起一个 ARP 请求的广播包（在发送自己的 ARP 请求时，同时会带上自己的 IP 地址到硬件地址的映射），收到请求的主机检查自己的 IP 地址和目的主机的 IP 地址是否一致，如果一致，则先保存源主机的映射到自己的 ARP 缓存，然后给源主机发送一个 ARP 响应数据包。源主机收到响应数据包之后，先添加目的主机的 IP 地址与 MAC 地址的映射，再进行数据传送。如果源主机一直没有收到响应，表示 ARP 查询失败。</p>\n<p>如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。</p>\n<h3 id=\"什么是nat-network-address-translation-网络地址转换\"><a class=\"anchor\" href=\"#什么是nat-network-address-translation-网络地址转换\">#</a> 什么是 NAT (Network Address Translation, 网络地址转换)？</h3>\n<p>用于解决内网中的主机要和因特网上的主机通信。由 NAT 路由器将主机的本地 IP 地址转换为全球 IP 地址，分为静态转换（转换得到的全球 IP 地址固定不变）和动态 NAT 转换。</p>\n<h3 id=\"参考\"><a class=\"anchor\" href=\"#参考\">#</a> 参考</h3>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3Rsb3ZleW91Xy9hcnRpY2xlL2RldGFpbHMvNzgzMDM2MTc=\">面试 / 笔试第一弹 —— 计算机网络面试问题集锦</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lqeHNkengvYXJ0aWNsZS9kZXRhaWxzLzcxOTM3ODg2\">什么时候选 TCP、UDP？</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhZF9zaGVlcC9hcnRpY2xlL2RldGFpbHMvNjE1ODY3Ng==\">TCP 速率与窗口，带宽，RTT 之间的关系</span></li>\n</ul>\n",
            "tags": [
                "计算机",
                "计算机网络"
            ]
        }
    ]
}